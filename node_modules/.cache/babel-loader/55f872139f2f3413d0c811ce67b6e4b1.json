{"ast":null,"code":"const RookFactory = color => {\n  //If direction is +1, generates moves up. If direction is -1, generates moves down\n  //Returns moves, which can be concatanated to a larger list of moves\n  const generateMovesVertically = (board, position, direction) => {\n    let moves = [];\n    let encounteredPiece = false;\n\n    for (let y = position[1] + direction; y < 8 && y >= 0 && !encounteredPiece; y = y + direction) {\n      //If the space is not empty\n      if (board[position[0]][y].piece !== null) {\n        encounteredPiece = true; //If the enocountered piece is not of the same color as this piece, add as a legal move\n\n        if (board[position[0]][y].piece.color !== this.color) {\n          moves.push([position, [position[0], y]]);\n        }\n      } //If the space is empty add as a legal move \n      else {\n        moves.push([position, [position[0], y]]);\n      }\n    }\n\n    return moves;\n  };\n\n  const generateMovesHorizontally = (board, position, direction) => {\n    let moves = [];\n    let encounteredPiece = false;\n\n    for (let x = position[1] + direction; x < 8 && x >= 0 && !encounteredPiece; x = x + direction) {\n      //If the space is not empty\n      if (board[x][position[1]].piece !== null) {\n        encounteredPiece = true; //If the enocountered piece is not of the same color as this piece, add as a legal move\n\n        if (board[x][position[1]].piece.color !== this.color) {\n          moves.push([position, [x, position[1]]]);\n        }\n      } //If the space is empty add as a legal move \n      else {\n        moves.push([position, [x, position[1]]]);\n      }\n    }\n\n    return moves;\n  };\n\n  return Object.create({\n    color: color,\n    piece: 'Rook',\n\n    //Position a two value array starting from lower left quadrant\n    //White's bottom row is 0, black's bottom row is 7\n    getMoves(board, position) {\n      let moves = []; //Moves up\n\n      moves = moves.concat(generateMovesVertically(board, position, 1)); //Moves down\n\n      moves = moves.concat(generateMovesVertically(board, position, -1)); //Moves left\n\n      moves = moves.concat(generateMovesHorizontally(board, position, 1)); //Moves right\n\n      moves = moves.concat(generateMovesHorizontally(board, position, -1));\n    }\n\n  });\n};\n\n_c = RookFactory;\nexport default RookFactory;\n\nvar _c;\n\n$RefreshReg$(_c, \"RookFactory\");","map":{"version":3,"sources":["C:/Users/dging/Programming/chess/src/model/Pieces/Rook.js"],"names":["RookFactory","color","generateMovesVertically","board","position","direction","moves","encounteredPiece","y","piece","push","generateMovesHorizontally","x","Object","create","getMoves","concat"],"mappings":"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","sourcesContent":["\r\nconst RookFactory = (color) => {\r\n\r\n    //If direction is +1, generates moves up. If direction is -1, generates moves down\r\n    //Returns moves, which can be concatanated to a larger list of moves\r\n    const generateMovesVertically = (board, position, direction) => {\r\n        let moves = [];\r\n        let encounteredPiece = false;\r\n\r\n        for (let y = position[1] + direction; y < 8 && y >= 0 && !encounteredPiece; y = y + direction) {\r\n            //If the space is not empty\r\n            if (board[position[0]][y].piece !== null) {\r\n                encounteredPiece = true;\r\n                //If the enocountered piece is not of the same color as this piece, add as a legal move\r\n                if (board[position[0]][y].piece.color !== this.color) {\r\n                    moves.push([position, [position[0], y]]);\r\n                }\r\n            } //If the space is empty add as a legal move \r\n            else {\r\n                moves.push([position, [position[0], y]]);\r\n            }\r\n        }\r\n\r\n        return moves;\r\n    }\r\n\r\n    const generateMovesHorizontally = (board, position, direction) => {\r\n        let moves = [];\r\n        let encounteredPiece = false;\r\n\r\n        for (let x = position[1] + direction; x < 8 && x >= 0 && !encounteredPiece; x = x + direction) {\r\n            //If the space is not empty\r\n            if (board[x][position[1]].piece !== null) {\r\n                encounteredPiece = true;\r\n                //If the enocountered piece is not of the same color as this piece, add as a legal move\r\n                if (board[x][position[1]].piece.color !== this.color) {\r\n                    moves.push([position, [x, position[1]]]);\r\n                }\r\n            } //If the space is empty add as a legal move \r\n            else {\r\n                moves.push([position, [x, position[1]]]);\r\n            }\r\n        }\r\n\r\n        return moves;\r\n    }\r\n\r\n    return Object.create({\r\n        color: color,\r\n        piece: 'Rook',\r\n\r\n        //Position a two value array starting from lower left quadrant\r\n        //White's bottom row is 0, black's bottom row is 7\r\n        getMoves(board, position) {\r\n            let moves = [];\r\n\r\n            //Moves up\r\n            moves = moves.concat(generateMovesVertically(board, position, 1));\r\n            //Moves down\r\n            moves = moves.concat(generateMovesVertically(board, position, -1));\r\n            //Moves left\r\n            moves = moves.concat(generateMovesHorizontally(board, position, 1));\r\n            //Moves right\r\n            moves = moves.concat(generateMovesHorizontally(board, position, -1));\r\n        }\r\n    })\r\n}\r\n\r\nexport default RookFactory;"]},"metadata":{},"sourceType":"module"}