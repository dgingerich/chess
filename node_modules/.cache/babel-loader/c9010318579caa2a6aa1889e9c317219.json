{"ast":null,"code":"const RookFactory = color => {\n  //Generates moves in a certain direction in increments\n  const generateIncrementalMoves = (board, position, color, xincrement, yincrement) => {\n    let moves = [];\n    let x = position[0] + xincrement;\n    let y = position[1] + yincrement;\n    let encounteredPiece = false; //Keeps adding moves until square is out of bounds or a piece is encountered\n\n    while (x >= 0 && x < 8 && y >= 0 && y < 8 && !encounteredPiece) {\n      //If the space is not empty\n      if (board[x][y] !== null) {\n        encounteredPiece = true; //If the enocountered piece is not of the same color as this piece, add as a legal move\n\n        if (board[x][y].color !== color) {\n          moves.push([position, [x, y]]);\n        }\n      } //If the space is empty add as a legal move \n      else {\n        moves.push([position, [x, y]]);\n      } //increment x and y\n\n\n      x = x + xincrement;\n      y = y + yincrement;\n    }\n\n    return moves;\n  };\n\n  return new Object.create({\n    color: color,\n    piece: 'Rook',\n\n    //Position a two value array starting from lower left quadrant\n    //White's bottom row is 0, black's bottom row is 7\n    getMoves(board, position) {\n      let moves = []; //Moves right\n\n      moves = moves.concat(generateIncrementalMoves(board, position, color, 1, 0)); //Moves left\n\n      moves = moves.concat(generateIncrementalMoves(board, position, color, -1, 0)); //Moves up\n\n      moves = moves.concat(generateIncrementalMoves(board, position, color, 0, 1)); //Moves down\n\n      moves = moves.concat(generateIncrementalMoves(board, position, color, 0, -1));\n      return moves;\n    }\n\n  });\n};\n\n_c = RookFactory;\nexport default RookFactory;\n\nvar _c;\n\n$RefreshReg$(_c, \"RookFactory\");","map":{"version":3,"sources":["C:/Users/dging/Programming/chess/src/model/Pieces/Rook.js"],"names":["RookFactory","color","generateIncrementalMoves","board","position","xincrement","yincrement","moves","x","y","encounteredPiece","push","Object","create","piece","getMoves","concat"],"mappings":"AACA,MAAMA,WAAW,GAAIC,KAAD,IAAW;AAE3B;AACA,QAAMC,wBAAwB,GAAG,CAACC,KAAD,EAAQC,QAAR,EAAkBH,KAAlB,EAAyBI,UAAzB,EAAqCC,UAArC,KAAoD;AACjF,QAAIC,KAAK,GAAG,EAAZ;AACA,QAAIC,CAAC,GAAGJ,QAAQ,CAAC,CAAD,CAAR,GAAcC,UAAtB;AACA,QAAII,CAAC,GAAGL,QAAQ,CAAC,CAAD,CAAR,GAAcE,UAAtB;AACA,QAAII,gBAAgB,GAAG,KAAvB,CAJiF,CAMjF;;AACA,WAAOF,CAAC,IAAI,CAAL,IAAUA,CAAC,GAAG,CAAd,IAAmBC,CAAC,IAAI,CAAxB,IAA6BA,CAAC,GAAG,CAAjC,IAAsC,CAACC,gBAA9C,EAAgE;AAC5D;AACA,UAAIP,KAAK,CAACK,CAAD,CAAL,CAASC,CAAT,MAAgB,IAApB,EAA0B;AACtBC,QAAAA,gBAAgB,GAAG,IAAnB,CADsB,CAEtB;;AACA,YAAIP,KAAK,CAACK,CAAD,CAAL,CAASC,CAAT,EAAYR,KAAZ,KAAsBA,KAA1B,EAAiC;AAC7BM,UAAAA,KAAK,CAACI,IAAN,CAAW,CAACP,QAAD,EAAW,CAACI,CAAD,EAAIC,CAAJ,CAAX,CAAX;AACH;AACJ,OAND,CAME;AANF,WAOK;AACDF,QAAAA,KAAK,CAACI,IAAN,CAAW,CAACP,QAAD,EAAW,CAACI,CAAD,EAAIC,CAAJ,CAAX,CAAX;AACH,OAX2D,CAY5D;;;AACAD,MAAAA,CAAC,GAAGA,CAAC,GAAGH,UAAR;AACAI,MAAAA,CAAC,GAAGA,CAAC,GAAGH,UAAR;AACH;;AAED,WAAOC,KAAP;AACH,GAzBD;;AA2BA,SAAO,IAAIK,MAAM,CAACC,MAAX,CAAkB;AACrBZ,IAAAA,KAAK,EAAEA,KADc;AAErBa,IAAAA,KAAK,EAAE,MAFc;;AAIrB;AACA;AACAC,IAAAA,QAAQ,CAACZ,KAAD,EAAQC,QAAR,EAAkB;AACtB,UAAIG,KAAK,GAAG,EAAZ,CADsB,CAGtB;;AACAA,MAAAA,KAAK,GAAGA,KAAK,CAACS,MAAN,CAAad,wBAAwB,CAACC,KAAD,EAAQC,QAAR,EAAkBH,KAAlB,EAAyB,CAAzB,EAA4B,CAA5B,CAArC,CAAR,CAJsB,CAKtB;;AACAM,MAAAA,KAAK,GAAGA,KAAK,CAACS,MAAN,CAAad,wBAAwB,CAACC,KAAD,EAAQC,QAAR,EAAkBH,KAAlB,EAAyB,CAAC,CAA1B,EAA6B,CAA7B,CAArC,CAAR,CANsB,CAOtB;;AACAM,MAAAA,KAAK,GAAGA,KAAK,CAACS,MAAN,CAAad,wBAAwB,CAACC,KAAD,EAAQC,QAAR,EAAkBH,KAAlB,EAAyB,CAAzB,EAA4B,CAA5B,CAArC,CAAR,CARsB,CAStB;;AACAM,MAAAA,KAAK,GAAGA,KAAK,CAACS,MAAN,CAAad,wBAAwB,CAACC,KAAD,EAAQC,QAAR,EAAkBH,KAAlB,EAAyB,CAAzB,EAA4B,CAAC,CAA7B,CAArC,CAAR;AAEA,aAAOM,KAAP;AACH;;AAnBoB,GAAlB,CAAP;AAqBH,CAnDD;;KAAMP,W;AAqDN,eAAeA,WAAf","sourcesContent":["\r\nconst RookFactory = (color) => {\r\n\r\n    //Generates moves in a certain direction in increments\r\n    const generateIncrementalMoves = (board, position, color, xincrement, yincrement) => {\r\n        let moves = [];\r\n        let x = position[0] + xincrement;\r\n        let y = position[1] + yincrement;\r\n        let encounteredPiece = false;\r\n\r\n        //Keeps adding moves until square is out of bounds or a piece is encountered\r\n        while (x >= 0 && x < 8 && y >= 0 && y < 8 && !encounteredPiece) {\r\n            //If the space is not empty\r\n            if (board[x][y] !== null) {\r\n                encounteredPiece = true;\r\n                //If the enocountered piece is not of the same color as this piece, add as a legal move\r\n                if (board[x][y].color !== color) {\r\n                    moves.push([position, [x, y]]);\r\n                }\r\n            } //If the space is empty add as a legal move \r\n            else {\r\n                moves.push([position, [x, y]]);\r\n            }\r\n            //increment x and y\r\n            x = x + xincrement;\r\n            y = y + yincrement;\r\n        }\r\n\r\n        return moves;\r\n    }\r\n\r\n    return new Object.create({\r\n        color: color,\r\n        piece: 'Rook',\r\n\r\n        //Position a two value array starting from lower left quadrant\r\n        //White's bottom row is 0, black's bottom row is 7\r\n        getMoves(board, position) {\r\n            let moves = [];\r\n\r\n            //Moves right\r\n            moves = moves.concat(generateIncrementalMoves(board, position, color, 1, 0));\r\n            //Moves left\r\n            moves = moves.concat(generateIncrementalMoves(board, position, color, -1, 0));\r\n            //Moves up\r\n            moves = moves.concat(generateIncrementalMoves(board, position, color, 0, 1));\r\n            //Moves down\r\n            moves = moves.concat(generateIncrementalMoves(board, position, color, 0, -1));\r\n\r\n            return moves;\r\n        }\r\n    });\r\n}\r\n\r\nexport default RookFactory;"]},"metadata":{},"sourceType":"module"}