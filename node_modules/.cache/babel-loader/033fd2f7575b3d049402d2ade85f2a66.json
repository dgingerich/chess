{"ast":null,"code":"import PawnFactory from \"./Pieces/Pawn\";\nimport RookFactory from \"./Pieces/Rook\";\nimport KnightFactory from \"./Pieces/Knight\";\nimport BishopFactory from \"./Pieces/Bishop\";\nimport QueenFactory from \"./Pieces/Queen\";\nimport KingFactory from \"./Pieces/King\";\n\nconst ChessFactory = () => {\n  const initializeBoard = () => {\n    return [[RookFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), RookFactory('black')], [KnightFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), KnightFactory('black')], [BishopFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), BishopFactory('black')], [QueenFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), QueenFactory('black')], [KingFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), KingFactory('black')], [BishopFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), BishopFactory('black')], [KnightFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), KnightFactory('black')], [RookFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), RookFactory('black')]];\n  }; //Generates list of moves given a board setup and the color of the current turn\n  //Checks if player is in check after move\n\n\n  const generateImmediateMoves = (board, turn) => {\n    let movesList = [];\n\n    for (let x = 0; x < 8; x = x + 1) {\n      for (let y = 0; y < 8; y = y + 1) {\n        if (board[x][y] !== null && board[x][y].color === turn) {\n          let position = [x, y];\n          movesList = movesList.concat(board[x][y].getMoves(board, position));\n        }\n      }\n    }\n\n    return movesList;\n  }; //2D arrays need to be deep copied so that the copied second dimension+ is copied to a new reference\n  //This function uses recursion to deep copy a >1D array by calling this function on all further dimensions\n  //Also calls deepCopyObject function to handle deep copying objects\n\n\n  const deepCopy = array => {\n    let copy = [];\n    array.forEach(element => {\n      if (Array.isArray(element)) {\n        copy.push(deepCopy(element));\n      } else if (element !== null && typeof element === 'object') {\n        console.log(element);\n        console.log(deepCopyObject(element));\n        copy.push(deepCopyObject(element));\n      } else {\n        copy.push(element);\n      }\n    });\n    return copy;\n  };\n\n  const deepCopyObject = obj => {\n    let objectCopy = {};\n\n    for (let [key, value] of Object.entries(obj)) {\n      console.log('here');\n      console.log(`${key}: ${value}`);\n\n      if (Array.isArray(value)) {\n        objectCopy[key] = deepCopy(value);\n      } else if (typeof value === 'object') {\n        objectCopy[key] = deepCopyObject(value);\n      } else {\n        objectCopy[key] = value;\n      }\n    }\n\n    return objectCopy;\n  };\n\n  return Object.create({\n    board: initializeBoard(),\n    turn: 'white',\n    movesList: generateImmediateMoves(initializeBoard(), 'white'),\n    moveHistory: [],\n\n    //generateMovesList isn't limited to current board and turn, in case a \n    generateMovesList(board, turn) {\n      let movesList = generateImmediateMoves(board, turn); //Loops through all moves and generates a new board for after each move\n      //Checks if player is in check \n      //If any of the opposing player's possible moves on the new board attack the player's king, move is illegal\n\n      for (let i = 0; i < movesList.length; i = i + 1) {\n        let move = movesList[i];\n        let resultingBoard = deepCopy(board);\n        let positionOfKingOnResultingBoard;\n        let nextTurn = turn === 'white' ? 'black' : 'white';\n        resultingBoard[move[1][0]][move[1][1]] = board[move[0][0]][move[0][1]];\n        resultingBoard[move[1][0]][move[1][1]] = null; //Gets location of king on board\n\n        for (let x = 0; x < 8; x = x + 1) {\n          for (let y = 0; y < 8; y = y + 1) {\n            if (resultingBoard[x][y] !== null) {//console.log(`${x}, ${y}: ${resultingBoard[x][y].color} ${resultingBoard[x][y].piece}`)\n            } else {//console.log(`${x}, ${y}: empty`)\n            }\n\n            if (resultingBoard[x][y] !== null && resultingBoard[x][y].color === turn && resultingBoard[x][y].piece === 'King') {\n              positionOfKingOnResultingBoard = [x, y];\n              console.log(x + ', ' + y);\n            }\n          }\n        }\n\n        let inCheck = false;\n        let nextTurnMovesList = generateImmediateMoves(resultingBoard, nextTurn);\n        nextTurnMovesList.forEach(move => {\n          if (JSON.stringify(move[1]) === JSON.stringify(positionOfKingOnResultingBoard)) inCheck = true;\n        });\n\n        if (inCheck) {\n          movesList.splice(i);\n          i = i - 1;\n        }\n      }\n\n      ;\n      return movesList;\n    },\n\n    //Move based on two positions\n    //I'll need to add functions for castling/converting pawn on end rank (should both of those go here?)\n    move(position1, position2) {\n      let moveInMovesList = false; //Check if move is in movesList\n\n      this.movesList.forEach(move => {\n        if (JSON.stringify(move) === JSON.stringify([position1, position2])) moveInMovesList = true;\n      }); //Logic if move is legal\n\n      if (moveInMovesList) {\n        //Sets position2 equal to value of position1\n        this.board[position2[0]][position2[1]] = this.board[position1[0]][position1[1]]; //Clears position1\n\n        this.board[position1[0]][position1[1]] = null; //Adds move to move history\n\n        this.moveHistory.push([position1, position2]); //Changes turn\n\n        if (this.turn === 'white') {\n          this.turn = 'black';\n        } else {\n          this.turn = 'white';\n        } //Re-generates movesList for new board and turn\n\n\n        this.movesList = this.generateMovesList(this.board, this.turn); //if movesList.length === 0 current turn wins\n        //if movesList contains a move that allows the king to be attacked, illegal move\n\n        return true;\n      } else {\n        return false;\n      }\n    },\n\n    printMoves() {\n      this.generateLegalMovesList(this.board, this.turn);\n      console.log(this.movesList);\n    }\n\n  });\n};\n\n_c = ChessFactory;\nexport default ChessFactory;\n\nvar _c;\n\n$RefreshReg$(_c, \"ChessFactory\");","map":{"version":3,"sources":["C:/Users/dging/Programming/chess/src/model/Chess.js"],"names":["PawnFactory","RookFactory","KnightFactory","BishopFactory","QueenFactory","KingFactory","ChessFactory","initializeBoard","generateImmediateMoves","board","turn","movesList","x","y","color","position","concat","getMoves","deepCopy","array","copy","forEach","element","Array","isArray","push","console","log","deepCopyObject","obj","objectCopy","key","value","Object","entries","create","moveHistory","generateMovesList","i","length","move","resultingBoard","positionOfKingOnResultingBoard","nextTurn","piece","inCheck","nextTurnMovesList","JSON","stringify","splice","position1","position2","moveInMovesList","printMoves","generateLegalMovesList"],"mappings":"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","sourcesContent":["import PawnFactory from \"./Pieces/Pawn\";\r\nimport RookFactory from \"./Pieces/Rook\";\r\nimport KnightFactory from \"./Pieces/Knight\";\r\nimport BishopFactory from \"./Pieces/Bishop\";\r\nimport QueenFactory from \"./Pieces/Queen\";\r\nimport KingFactory from \"./Pieces/King\";\r\n\r\nconst ChessFactory = () => {\r\n\r\n    const initializeBoard = () => {\r\n        return ([\r\n            [RookFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), RookFactory('black')],\r\n            [KnightFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), KnightFactory('black')],\r\n            [BishopFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), BishopFactory('black')],\r\n            [QueenFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), QueenFactory('black')],\r\n            [KingFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), KingFactory('black')],\r\n            [BishopFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), BishopFactory('black')],\r\n            [KnightFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), KnightFactory('black')],\r\n            [RookFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), RookFactory('black')],\r\n        ]);\r\n    };\r\n\r\n    //Generates list of moves given a board setup and the color of the current turn\r\n    //Checks if player is in check after move\r\n    const generateImmediateMoves = (board, turn) => {\r\n\r\n        let movesList = [];\r\n\r\n        for (let x = 0; x < 8; x = x + 1) {\r\n            for (let y = 0; y < 8; y = y + 1) {\r\n                if (board[x][y] !== null && board[x][y].color === turn) {\r\n                    let position = [x, y];\r\n                    movesList = movesList.concat(board[x][y].getMoves(board, position));\r\n                }\r\n            }\r\n        }\r\n\r\n        return movesList;\r\n    }\r\n\r\n    //2D arrays need to be deep copied so that the copied second dimension+ is copied to a new reference\r\n    //This function uses recursion to deep copy a >1D array by calling this function on all further dimensions\r\n    //Also calls deepCopyObject function to handle deep copying objects\r\n    const deepCopy = (array) => {\r\n        let copy = [];\r\n\r\n        array.forEach(element => {\r\n            if (Array.isArray(element)) {\r\n                copy.push(deepCopy(element));\r\n            } else if (element !== null && typeof element === 'object') {\r\n                console.log(element)\r\n                console.log(deepCopyObject(element))\r\n                copy.push(deepCopyObject(element));\r\n            } else {\r\n                copy.push(element);\r\n            }\r\n        });\r\n\r\n        return copy;\r\n    }\r\n\r\n    const deepCopyObject = (obj) => {\r\n        let objectCopy = {};\r\n\r\n        for (let [key, value] of Object.entries(obj)) {\r\n        console.log('here')\r\n            console.log(`${key}: ${value}`);\r\n            if (Array.isArray(value)) {\r\n                objectCopy[key] = deepCopy(value);\r\n            } else if (typeof value === 'object') {\r\n                objectCopy[key] = deepCopyObject(value);\r\n            } else {\r\n                objectCopy[key] = value;\r\n            }\r\n        }\r\n        return objectCopy;\r\n    }\r\n\r\n    return Object.create({\r\n        board: initializeBoard(),\r\n        turn: 'white',\r\n        movesList: generateImmediateMoves(initializeBoard(), 'white'),\r\n        moveHistory: [],\r\n\r\n        //generateMovesList isn't limited to current board and turn, in case a \r\n        generateMovesList(board, turn) {\r\n            let movesList = generateImmediateMoves(board, turn);\r\n\r\n            //Loops through all moves and generates a new board for after each move\r\n            //Checks if player is in check \r\n            //If any of the opposing player's possible moves on the new board attack the player's king, move is illegal\r\n            for (let i = 0; i < movesList.length; i = i + 1) {\r\n                let move = movesList[i];\r\n                let resultingBoard = deepCopy(board);\r\n                let positionOfKingOnResultingBoard;\r\n                let nextTurn = (turn === 'white') ? 'black' : 'white';\r\n                resultingBoard[move[1][0]][move[1][1]] = board[move[0][0]][move[0][1]];\r\n                resultingBoard[move[1][0]][move[1][1]] = null;\r\n\r\n                //Gets location of king on board\r\n                for (let x = 0; x < 8; x = x + 1) {\r\n                    for (let y = 0; y < 8; y = y + 1) {\r\n                        if (resultingBoard[x][y] !== null) {\r\n                            //console.log(`${x}, ${y}: ${resultingBoard[x][y].color} ${resultingBoard[x][y].piece}`)\r\n                        } else {\r\n                            //console.log(`${x}, ${y}: empty`)\r\n                        }\r\n                        if (resultingBoard[x][y] !== null && resultingBoard[x][y].color === turn && resultingBoard[x][y].piece === 'King') {\r\n                            positionOfKingOnResultingBoard = [x, y];\r\n                            console.log(x + ', ' + y)\r\n                        }\r\n                    }\r\n                }\r\n\r\n                let inCheck = false;\r\n                let nextTurnMovesList = generateImmediateMoves(resultingBoard, nextTurn);\r\n\r\n                nextTurnMovesList.forEach(move => {\r\n                    if (JSON.stringify(move[1]) === JSON.stringify(positionOfKingOnResultingBoard)) inCheck = true;\r\n                });\r\n\r\n                if (inCheck) {\r\n                    movesList.splice(i);\r\n                    i = i - 1;\r\n                }\r\n\r\n            };\r\n\r\n            return movesList\r\n        },\r\n\r\n        //Move based on two positions\r\n        //I'll need to add functions for castling/converting pawn on end rank (should both of those go here?)\r\n        move(position1, position2) {\r\n\r\n            let moveInMovesList = false;\r\n\r\n            //Check if move is in movesList\r\n            this.movesList.forEach(move => {\r\n                if (JSON.stringify(move) === JSON.stringify([position1, position2])) moveInMovesList = true;\r\n            });\r\n\r\n            //Logic if move is legal\r\n            if (moveInMovesList) {\r\n                //Sets position2 equal to value of position1\r\n                this.board[position2[0]][position2[1]] = this.board[position1[0]][position1[1]];\r\n                //Clears position1\r\n                this.board[position1[0]][position1[1]] = null;\r\n                //Adds move to move history\r\n                this.moveHistory.push([position1, position2]);\r\n                //Changes turn\r\n                if (this.turn === 'white') {\r\n                    this.turn = 'black';\r\n                } else {\r\n                    this.turn = 'white';\r\n                }\r\n                //Re-generates movesList for new board and turn\r\n                this.movesList = this.generateMovesList(this.board, this.turn);\r\n                //if movesList.length === 0 current turn wins\r\n                //if movesList contains a move that allows the king to be attacked, illegal move\r\n                return true;\r\n            } else {\r\n                return false;\r\n            }\r\n        },\r\n        printMoves() {\r\n            this.generateLegalMovesList(this.board, this.turn);\r\n            console.log(this.movesList);\r\n        }\r\n    })\r\n\r\n}\r\n\r\nexport default ChessFactory;"]},"metadata":{},"sourceType":"module"}