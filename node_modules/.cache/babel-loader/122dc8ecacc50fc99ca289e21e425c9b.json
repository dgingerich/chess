{"ast":null,"code":"const PawnFactory = color => {\n  //Generates moves in a certain direction in increments\n  const generateMoves = (board, position, color) => {\n    let moves = [];\n    let x = position[0];\n    let y = position[1]; //White pawns go up, black pawns go down\n\n    let direction = color === 'white' ? 1 : -1; //Makes sure movement is within bounds\n\n    if (y + direction < 8 && y + direction >= 0) {\n      //Move forward if square is open\n      if (board[x][y + direction] === null) {\n        moves.push([position, [x, y + direction]]);\n      } //Diagonally capture piece to the left \n\n\n      if (x - 1 >= 0 && board[x - 1][y + direction] !== null && board[x - 1][y + direction].color !== color) {\n        moves.push([position, [x - 1, y + direction]]);\n      } //Diagonally capture piece to the right\n\n\n      if (x + 1 < 8 && board[x + 1][y + direction] !== null && board[x + 1][y + direction].color !== color) {\n        moves.push([position, [x + 1, y + direction]]);\n      }\n    } //Double move for initial pawn move\n\n\n    if (y + 2 * direction < 8 && y + 2 * direction >= 0 && board[x][y + 2 * direction] === null && (color === 'white' && y === 1 || color === 'black' && y === 6)) {\n      moves.push([position, [x, y + 2 * direction]]);\n    }\n\n    return moves;\n  };\n\n  return newObject.create({\n    color: color,\n    piece: 'Pawn',\n\n    //Position a two value array starting from lower left quadrant\n    getMoves(board, position) {\n      let moves = [];\n      moves = moves.concat(generateMoves(board, position, this.color));\n      return moves;\n    }\n\n  });\n};\n\n_c = PawnFactory;\nexport default PawnFactory;\n\nvar _c;\n\n$RefreshReg$(_c, \"PawnFactory\");","map":{"version":3,"sources":["C:/Users/dging/Programming/chess/src/model/Pieces/Pawn.js"],"names":["PawnFactory","color","generateMoves","board","position","moves","x","y","direction","push","newObject","create","piece","getMoves","concat"],"mappings":"AACA,MAAMA,WAAW,GAAIC,KAAD,IAAW;AAE3B;AACA,QAAMC,aAAa,GAAG,CAACC,KAAD,EAAQC,QAAR,EAAkBH,KAAlB,KAA4B;AAC9C,QAAII,KAAK,GAAG,EAAZ;AACA,QAAIC,CAAC,GAAGF,QAAQ,CAAC,CAAD,CAAhB;AACA,QAAIG,CAAC,GAAGH,QAAQ,CAAC,CAAD,CAAhB,CAH8C,CAI9C;;AACA,QAAII,SAAS,GAAIP,KAAK,KAAK,OAAX,GAAsB,CAAtB,GAA0B,CAAC,CAA3C,CAL8C,CAO9C;;AACA,QAAIM,CAAC,GAAGC,SAAJ,GAAgB,CAAhB,IAAqBD,CAAC,GAAGC,SAAJ,IAAiB,CAA1C,EAA6C;AACzC;AACA,UAAIL,KAAK,CAACG,CAAD,CAAL,CAASC,CAAC,GAAGC,SAAb,MAA4B,IAAhC,EAAsC;AAClCH,QAAAA,KAAK,CAACI,IAAN,CAAW,CAACL,QAAD,EAAW,CAACE,CAAD,EAAIC,CAAC,GAAGC,SAAR,CAAX,CAAX;AACH,OAJwC,CAKzC;;;AACA,UAAIF,CAAC,GAAG,CAAJ,IAAS,CAAT,IAAcH,KAAK,CAACG,CAAC,GAAG,CAAL,CAAL,CAAaC,CAAC,GAAGC,SAAjB,MAAgC,IAA9C,IAAsDL,KAAK,CAACG,CAAC,GAAG,CAAL,CAAL,CAAaC,CAAC,GAAGC,SAAjB,EAA4BP,KAA5B,KAAsCA,KAAhG,EAAuG;AACnGI,QAAAA,KAAK,CAACI,IAAN,CAAW,CAACL,QAAD,EAAW,CAACE,CAAC,GAAG,CAAL,EAAQC,CAAC,GAAGC,SAAZ,CAAX,CAAX;AACH,OARwC,CASzC;;;AACA,UAAIF,CAAC,GAAG,CAAJ,GAAQ,CAAR,IAAaH,KAAK,CAACG,CAAC,GAAG,CAAL,CAAL,CAAaC,CAAC,GAAGC,SAAjB,MAAgC,IAA7C,IAAqDL,KAAK,CAACG,CAAC,GAAG,CAAL,CAAL,CAAaC,CAAC,GAAGC,SAAjB,EAA4BP,KAA5B,KAAsCA,KAA/F,EAAsG;AAClGI,QAAAA,KAAK,CAACI,IAAN,CAAW,CAACL,QAAD,EAAW,CAACE,CAAC,GAAG,CAAL,EAAQC,CAAC,GAAGC,SAAZ,CAAX,CAAX;AACH;AACJ,KArB6C,CAsB9C;;;AACA,QAAID,CAAC,GAAG,IAAIC,SAAR,GAAoB,CAApB,IAAyBD,CAAC,GAAG,IAAIC,SAAR,IAAqB,CAA9C,IAAmDL,KAAK,CAACG,CAAD,CAAL,CAASC,CAAC,GAAG,IAAIC,SAAjB,MAAgC,IAAnF,KAA6FP,KAAK,KAAK,OAAV,IAAqBM,CAAC,KAAK,CAA5B,IAAmCN,KAAK,KAAK,OAAV,IAAqBM,CAAC,KAAK,CAA1J,CAAJ,EAAmK;AAC/JF,MAAAA,KAAK,CAACI,IAAN,CAAW,CAACL,QAAD,EAAW,CAACE,CAAD,EAAIC,CAAC,GAAG,IAAIC,SAAZ,CAAX,CAAX;AACH;;AAED,WAAOH,KAAP;AACH,GA5BD;;AA8BA,SAAOK,SAAS,CAACC,MAAV,CAAiB;AACpBV,IAAAA,KAAK,EAAEA,KADa;AAEpBW,IAAAA,KAAK,EAAE,MAFa;;AAIpB;AACAC,IAAAA,QAAQ,CAACV,KAAD,EAAQC,QAAR,EAAkB;AACtB,UAAIC,KAAK,GAAG,EAAZ;AAEAA,MAAAA,KAAK,GAAGA,KAAK,CAACS,MAAN,CAAaZ,aAAa,CAACC,KAAD,EAAQC,QAAR,EAAkB,KAAKH,KAAvB,CAA1B,CAAR;AAEA,aAAOI,KAAP;AACH;;AAXmB,GAAjB,CAAP;AAaH,CA9CD;;KAAML,W;AAgDN,eAAeA,WAAf","sourcesContent":["\r\nconst PawnFactory = (color) => {\r\n\r\n    //Generates moves in a certain direction in increments\r\n    const generateMoves = (board, position, color) => {\r\n        let moves = [];\r\n        let x = position[0];\r\n        let y = position[1];\r\n        //White pawns go up, black pawns go down\r\n        let direction = (color === 'white') ? 1 : -1;\r\n\r\n        //Makes sure movement is within bounds\r\n        if (y + direction < 8 && y + direction >= 0) {\r\n            //Move forward if square is open\r\n            if (board[x][y + direction] === null) {\r\n                moves.push([position, [x, y + direction]]);\r\n            }\r\n            //Diagonally capture piece to the left \r\n            if (x - 1 >= 0 && board[x - 1][y + direction] !== null && board[x - 1][y + direction].color !== color) {\r\n                moves.push([position, [x - 1, y + direction]]);\r\n            }\r\n            //Diagonally capture piece to the right\r\n            if (x + 1 < 8 && board[x + 1][y + direction] !== null && board[x + 1][y + direction].color !== color) {\r\n                moves.push([position, [x + 1, y + direction]]);\r\n            }\r\n        }\r\n        //Double move for initial pawn move\r\n        if (y + 2 * direction < 8 && y + 2 * direction >= 0 && board[x][y + 2 * direction] === null && ((color === 'white' && y === 1) || (color === 'black' && y === 6))) {\r\n            moves.push([position, [x, y + 2 * direction]]);\r\n        }\r\n\r\n        return moves;\r\n    }\r\n\r\n    return newObject.create({\r\n        color: color,\r\n        piece: 'Pawn',\r\n\r\n        //Position a two value array starting from lower left quadrant\r\n        getMoves(board, position) {\r\n            let moves = [];\r\n\r\n            moves = moves.concat(generateMoves(board, position, this.color));\r\n\r\n            return moves;\r\n        }\r\n    })\r\n}\r\n\r\nexport default PawnFactory;"]},"metadata":{},"sourceType":"module"}