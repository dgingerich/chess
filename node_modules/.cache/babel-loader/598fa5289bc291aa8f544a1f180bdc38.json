{"ast":null,"code":"import PawnFactory from \"./Pieces/Pawn\";\nimport RookFactory from \"./Pieces/Rook\";\nimport KnightFactory from \"./Pieces/Knight\";\nimport BishopFactory from \"./Pieces/Bishop\";\nimport QueenFactory from \"./Pieces/Queen\";\nimport KingFactory from \"./Pieces/King\";\n\nconst ChessFactory = () => {\n  const initializeBoard = () => {\n    return [[RookFactory('white'), null, null, null, null, null, null, RookFactory('black')], [KnightFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), KnightFactory('black')], [BishopFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), BishopFactory('black')], [QueenFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), QueenFactory('black')], [KingFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), KingFactory('black')], [BishopFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), BishopFactory('black')], [KnightFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), KnightFactory('black')], [RookFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), RookFactory('black')]];\n  };\n\n  const boardToString = board => {\n    let boardString = '';\n    let count = 0;\n    board.forEach(row => {\n      boardString = boardString.concat(`${count} `);\n      row.forEach(square => {\n        if (square === null) {\n          boardString = boardString.concat('null, ');\n        } else {\n          boardString = boardString.concat(`${square.piece}, `);\n        }\n      });\n      boardString = boardString.concat('\\n');\n      count = count + 1;\n    }); //Adds columns at bottom\n\n    boardString = boardString.concat(`   0    1     2     3     4      5      6      7`);\n    return boardString;\n  }; //Generates list of moves given a board setup and the color of the current turn\n  //maybe\n  //returns True if move is successful, returns False if not successful\n\n\n  const generateMovesList = (board, turn) => {\n    let movesList = [];\n\n    for (let x = 0; x < 8; x = x + 1) {\n      for (let y = 0; y < 8; y = y + 1) {\n        if (board[x][y] !== null && board[x][y].color === turn) {\n          let position = [x, y];\n          movesList = movesList.concat(board[x][y].getMoves(board, position));\n        }\n      }\n    }\n\n    return movesList;\n  };\n\n  return Object.create({\n    board: initializeBoard(),\n    turn: 'white',\n    movesList: generateMovesList(initializeBoard(), 'white'),\n\n    //generateMovesList isn't limited to current board and turn, in case a \n    generateMovesList(board, turn) {\n      return generateMovesList(board, turn);\n    },\n\n    //Move based on two positions\n    //I'll need to add functions for castling/converting pawn on end rank (should both of those go here?)\n    move(position1, position2) {\n      let moveInMovesList = false; //Check if move is in movesList\n\n      this.movesList.forEach(move => {\n        console.log([position1, position2]);\n        console.log(move);\n        if (JSON.stringify(move) === JSON.stringify([position1, position2])) moveInMovesList = true;\n        console.log(JSON.stringify(move) === JSON.stringify([position1, position2]));\n      }); //Logic if move is legal\n\n      if (moveInMovesList) {\n        //Sets position2 equal to value of position1\n        this.board[position2[0]][position2[1]] = this.board[position1[0]][position1[1]]; //Clears position1\n\n        this.board[position1[0]][position1[1]] = null; //Changes turn\n\n        if (this.turn === 'white') {\n          this.turn = 'black';\n        } else {\n          this.turn = 'white';\n        } //Re-generates movesList for new board and turn\n\n\n        this.movesList = generateMovesList(this.board, this.turn); //if movesList.length === 0 current turn wins\n        //if movesList contains a move that allows the king to be attacked, illegal move\n\n        return true;\n      } else {\n        return false;\n      }\n    },\n\n    printBoard() {\n      console.log(this.board.boardToString());\n    },\n\n    printMoves() {\n      this.generateMovesList(this.board, this.turn);\n      console.log(this.movesList);\n    }\n\n  });\n};\n\n_c = ChessFactory;\nexport default ChessFactory;\n\nvar _c;\n\n$RefreshReg$(_c, \"ChessFactory\");","map":{"version":3,"sources":["C:/Users/dging/Programming/chess/src/model/Chess.js"],"names":["PawnFactory","RookFactory","KnightFactory","BishopFactory","QueenFactory","KingFactory","ChessFactory","initializeBoard","boardToString","board","boardString","count","forEach","row","concat","square","piece","generateMovesList","turn","movesList","x","y","color","position","getMoves","Object","create","move","position1","position2","moveInMovesList","console","log","JSON","stringify","printBoard","printMoves"],"mappings":"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","sourcesContent":["import PawnFactory from \"./Pieces/Pawn\";\r\nimport RookFactory from \"./Pieces/Rook\";\r\nimport KnightFactory from \"./Pieces/Knight\";\r\nimport BishopFactory from \"./Pieces/Bishop\";\r\nimport QueenFactory from \"./Pieces/Queen\";\r\nimport KingFactory from \"./Pieces/King\";\r\n\r\nconst ChessFactory = () => {\r\n\r\n    const initializeBoard = () => {\r\n\r\n        return ([\r\n            [RookFactory('white'), null, null, null, null, null, null, RookFactory('black')],\r\n            [KnightFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), KnightFactory('black')],\r\n            [BishopFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), BishopFactory('black')],\r\n            [QueenFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), QueenFactory('black')],\r\n            [KingFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), KingFactory('black')],\r\n            [BishopFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), BishopFactory('black')],\r\n            [KnightFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), KnightFactory('black')],\r\n            [RookFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), RookFactory('black')],\r\n\r\n        ]);\r\n    };\r\n\r\n    const boardToString = (board) => {\r\n\r\n        let boardString = '';\r\n        let count = 0;\r\n\r\n        board.forEach(row => {\r\n            boardString = boardString.concat(`${count} `);\r\n            row.forEach(square => {\r\n                if (square === null) {\r\n                    boardString = boardString.concat('null, ')\r\n                } else {\r\n                    boardString = boardString.concat(`${square.piece}, `);\r\n                }\r\n            })\r\n            boardString = boardString.concat('\\n');\r\n            count = count + 1;\r\n        });\r\n\r\n        //Adds columns at bottom\r\n        boardString = boardString.concat(`   0    1     2     3     4      5      6      7`);\r\n\r\n        return (boardString);\r\n    };\r\n\r\n    //Generates list of moves given a board setup and the color of the current turn\r\n    //maybe\r\n    //returns True if move is successful, returns False if not successful\r\n    const generateMovesList = (board, turn) => {\r\n\r\n        let movesList = [];\r\n\r\n        for (let x = 0; x < 8; x = x + 1) {\r\n            for (let y = 0; y < 8; y = y + 1) {\r\n                if (board[x][y] !== null && board[x][y].color === turn) {\r\n                    let position = [x, y];\r\n                    movesList = movesList.concat(board[x][y].getMoves(board, position));\r\n                }\r\n            }\r\n        }\r\n\r\n        return movesList;\r\n    }\r\n\r\nreturn Object.create({\r\n    board: initializeBoard(),\r\n    turn: 'white',\r\n    movesList: generateMovesList(initializeBoard(), 'white'),\r\n\r\n    //generateMovesList isn't limited to current board and turn, in case a \r\n    generateMovesList(board, turn) {\r\n        return generateMovesList(board, turn);\r\n    },\r\n\r\n    //Move based on two positions\r\n    //I'll need to add functions for castling/converting pawn on end rank (should both of those go here?)\r\n    move(position1, position2) {\r\n\r\n        let moveInMovesList = false;\r\n\r\n        //Check if move is in movesList\r\n        this.movesList.forEach(move => {\r\n            console.log([position1, position2]);\r\n            console.log(move);\r\n            if (JSON.stringify(move) === JSON.stringify([position1, position2])) moveInMovesList = true;\r\n            console.log(JSON.stringify(move) === JSON.stringify([position1, position2]))\r\n        });\r\n\r\n        //Logic if move is legal\r\n        if (moveInMovesList) {\r\n            //Sets position2 equal to value of position1\r\n            this.board[position2[0]][position2[1]] = this.board[position1[0]][position1[1]];\r\n            //Clears position1\r\n            this.board[position1[0]][position1[1]] = null;\r\n            //Changes turn\r\n            if (this.turn === 'white') {\r\n                this.turn = 'black';\r\n            } else {\r\n                this.turn = 'white';\r\n            }\r\n            //Re-generates movesList for new board and turn\r\n            this.movesList = generateMovesList(this.board, this.turn);\r\n            //if movesList.length === 0 current turn wins\r\n            //if movesList contains a move that allows the king to be attacked, illegal move\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    },\r\n\r\n    printBoard() {\r\n        console.log(this.board.boardToString());\r\n    },\r\n    printMoves() {\r\n        this.generateMovesList(this.board, this.turn);\r\n        console.log(this.movesList);\r\n    }\r\n})\r\n\r\n}\r\n\r\nexport default ChessFactory;"]},"metadata":{},"sourceType":"module"}