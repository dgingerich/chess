{"ast":null,"code":"import PawnFactory from \"./Pieces/Pawn\";\nimport RookFactory from \"./Pieces/Rook\";\nimport KnightFactory from \"./Pieces/Knight\";\nimport BishopFactory from \"./Pieces/Bishop\";\nimport QueenFactory from \"./Pieces/Queen\";\nimport KingFactory from \"./Pieces/King\";\n\nconst ChessFactory = () => {\n  const initializeBoard = () => {\n    return [[RookFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), RookFactory('black')], [KnightFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), KnightFactory('black')], [BishopFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), BishopFactory('black')], [QueenFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), QueenFactory('black')], [KingFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), KingFactory('black')], [BishopFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), BishopFactory('black')], [KnightFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), KnightFactory('black')], [RookFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), RookFactory('black')]];\n  }; //Generates list of moves given a board setup and the color of the current turn\n  //Checks if player is in check after move\n\n\n  const generateImmediateMoves = (board, turn) => {\n    let movesList = [];\n\n    for (let x = 0; x < 8; x = x + 1) {\n      for (let y = 0; y < 8; y = y + 1) {\n        if (board[x][y] !== null && board[x][y].color === turn) {\n          let position = [x, y];\n          movesList = movesList.concat(board[x][y].getMoves(board, position));\n        }\n      }\n    }\n\n    return movesList;\n  };\n\n  return Object.create({\n    board: initializeBoard(),\n    turn: 'white',\n    movesList: generateImmediateMoves(initializeBoard(), 'white'),\n    moveHistory: [],\n\n    //generateMovesList isn't limited to current board and turn, in case a \n    generateMovesList(board, turn) {\n      let movesList = generateImmediateMoves(board, turn); //Loops through all moves and generates a new board for after each move\n      //Checks if player is in check \n      //If any of the opposing player's possible moves on the new board attack the player's king, move is illegal\n\n      for (let i = 0; i < movesList.length; i = i + 1) {\n        let move = movesList[i];\n        console.log(move);\n        let resultingBoard = [...board];\n        let positionOfKingOnResultingBoard;\n        let nextTurn = turn === 'white' ? 'black' : 'white';\n        resultingBoard[move[1][0]].splice([move[1][1]], 1, board[move[0][0]][move[0][1]]);\n        resultingBoard[move[0][0]].splice([move[0][1]], 1, null); // for (let x = 0; x < 8; x = x + 1) {\n        //     for (let y = 0; y < 8; y = y + 1) {\n        //         if (resultingBoard[x][y] !== null && resultingBoard[x][y].color === turn && resultingBoard[x][y].piece === 'King') {\n        //             positionOfKingOnResultingBoard = [x, y];\n        //         }\n        //     }\n        // }\n        // let inCheck = false;\n        // let nextTurnMovesList = generateImmediateMoves(resultingBoard, nextTurn);\n        // nextTurnMovesList.forEach(move => {\n        //     if (JSON.stringify(move[1]) === JSON.stringify(positionOfKingOnResultingBoard)) inCheck = true;\n        // });\n        // if (inCheck) {\n        //     movesList.splice(i);\n        //     i = i - 1;\n        // }\n      }\n\n      ;\n      return movesList;\n    },\n\n    //Move based on two positions\n    //I'll need to add functions for castling/converting pawn on end rank (should both of those go here?)\n    move(position1, position2) {\n      let moveInMovesList = false; //Check if move is in movesList\n\n      this.movesList.forEach(move => {\n        if (JSON.stringify(move) === JSON.stringify([position1, position2])) moveInMovesList = true;\n      }); //Logic if move is legal\n\n      if (moveInMovesList) {\n        //Sets position2 equal to value of position1\n        this.board[position2[0]][position2[1]] = this.board[position1[0]][position1[1]]; //Clears position1\n\n        this.board[position1[0]][position1[1]] = null; //Adds move to move history\n\n        this.moveHistory.push([position1, position2]); //Changes turn\n\n        if (this.turn === 'white') {\n          this.turn = 'black';\n        } else {\n          this.turn = 'white';\n        } //Re-generates movesList for new board and turn\n\n\n        this.movesList = this.generateMovesList(this.board, this.turn); //if movesList.length === 0 current turn wins\n        //if movesList contains a move that allows the king to be attacked, illegal move\n\n        return true;\n      } else {\n        return false;\n      }\n    },\n\n    printMoves() {\n      this.generateLegalMovesList(this.board, this.turn);\n      console.log(this.movesList);\n    }\n\n  });\n};\n\n_c = ChessFactory;\nexport default ChessFactory;\n\nvar _c;\n\n$RefreshReg$(_c, \"ChessFactory\");","map":{"version":3,"sources":["C:/Users/dging/Programming/chess/src/model/Chess.js"],"names":["PawnFactory","RookFactory","KnightFactory","BishopFactory","QueenFactory","KingFactory","ChessFactory","initializeBoard","generateImmediateMoves","board","turn","movesList","x","y","color","position","concat","getMoves","Object","create","moveHistory","generateMovesList","i","length","move","console","log","resultingBoard","positionOfKingOnResultingBoard","nextTurn","splice","position1","position2","moveInMovesList","forEach","JSON","stringify","push","printMoves","generateLegalMovesList"],"mappings":"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","sourcesContent":["import PawnFactory from \"./Pieces/Pawn\";\r\nimport RookFactory from \"./Pieces/Rook\";\r\nimport KnightFactory from \"./Pieces/Knight\";\r\nimport BishopFactory from \"./Pieces/Bishop\";\r\nimport QueenFactory from \"./Pieces/Queen\";\r\nimport KingFactory from \"./Pieces/King\";\r\n\r\nconst ChessFactory = () => {\r\n\r\n    const initializeBoard = () => {\r\n        return ([\r\n            [RookFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), RookFactory('black')],\r\n            [KnightFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), KnightFactory('black')],\r\n            [BishopFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), BishopFactory('black')],\r\n            [QueenFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), QueenFactory('black')],\r\n            [KingFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), KingFactory('black')],\r\n            [BishopFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), BishopFactory('black')],\r\n            [KnightFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), KnightFactory('black')],\r\n            [RookFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), RookFactory('black')],\r\n        ]);\r\n    };\r\n\r\n    //Generates list of moves given a board setup and the color of the current turn\r\n    //Checks if player is in check after move\r\n    const generateImmediateMoves = (board, turn) => {\r\n\r\n        let movesList = [];\r\n\r\n        for (let x = 0; x < 8; x = x + 1) {\r\n            for (let y = 0; y < 8; y = y + 1) {\r\n                if (board[x][y] !== null && board[x][y].color === turn) {\r\n                    let position = [x, y];\r\n                    movesList = movesList.concat(board[x][y].getMoves(board, position));\r\n                }\r\n            }\r\n        }\r\n\r\n\r\n        return movesList;\r\n    }\r\n\r\nreturn Object.create({\r\n    board: initializeBoard(),\r\n    turn: 'white',\r\n    movesList: generateImmediateMoves(initializeBoard(), 'white'),\r\n    moveHistory: [],\r\n\r\n    //generateMovesList isn't limited to current board and turn, in case a \r\n    generateMovesList(board, turn) { \r\n        let movesList = generateImmediateMoves(board, turn);\r\n\r\n        //Loops through all moves and generates a new board for after each move\r\n        //Checks if player is in check \r\n        //If any of the opposing player's possible moves on the new board attack the player's king, move is illegal\r\n        for (let i = 0; i < movesList.length; i = i + 1) {\r\n            let move = movesList[i];\r\n            console.log(move)\r\n            let resultingBoard = [...board];\r\n            let positionOfKingOnResultingBoard;\r\n            let nextTurn = (turn === 'white') ? 'black' : 'white';\r\n            resultingBoard[move[1][0]].splice([move[1][1]], 1, board[move[0][0]][move[0][1]]);\r\n            resultingBoard[move[0][0]].splice([move[0][1]], 1, null);\r\n\r\n            // for (let x = 0; x < 8; x = x + 1) {\r\n            //     for (let y = 0; y < 8; y = y + 1) {\r\n            //         if (resultingBoard[x][y] !== null && resultingBoard[x][y].color === turn && resultingBoard[x][y].piece === 'King') {\r\n            //             positionOfKingOnResultingBoard = [x, y];\r\n            //         }\r\n            //     }\r\n            // }\r\n\r\n            // let inCheck = false;\r\n            // let nextTurnMovesList = generateImmediateMoves(resultingBoard, nextTurn);\r\n\r\n            // nextTurnMovesList.forEach(move => {\r\n            //     if (JSON.stringify(move[1]) === JSON.stringify(positionOfKingOnResultingBoard)) inCheck = true;\r\n            // });\r\n            \r\n            // if (inCheck) {\r\n            //     movesList.splice(i);\r\n            //     i = i - 1;\r\n            // }\r\n\r\n        };\r\n\r\n        return movesList\r\n    },\r\n\r\n    //Move based on two positions\r\n    //I'll need to add functions for castling/converting pawn on end rank (should both of those go here?)\r\n    move(position1, position2) {\r\n\r\n        let moveInMovesList = false;\r\n\r\n        //Check if move is in movesList\r\n        this.movesList.forEach(move => {\r\n            if (JSON.stringify(move) === JSON.stringify([position1, position2])) moveInMovesList = true;\r\n        });\r\n\r\n        //Logic if move is legal\r\n        if (moveInMovesList) {\r\n            //Sets position2 equal to value of position1\r\n            this.board[position2[0]][position2[1]] = this.board[position1[0]][position1[1]];\r\n            //Clears position1\r\n            this.board[position1[0]][position1[1]] = null;\r\n            //Adds move to move history\r\n            this.moveHistory.push([position1, position2]);\r\n            //Changes turn\r\n            if (this.turn === 'white') {\r\n                this.turn = 'black';\r\n            } else {\r\n                this.turn = 'white';\r\n            }\r\n            //Re-generates movesList for new board and turn\r\n            this.movesList = this.generateMovesList(this.board, this.turn);\r\n            //if movesList.length === 0 current turn wins\r\n            //if movesList contains a move that allows the king to be attacked, illegal move\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    },\r\n    printMoves() {\r\n        this.generateLegalMovesList(this.board, this.turn);\r\n        console.log(this.movesList);\r\n    }\r\n})\r\n\r\n}\r\n\r\nexport default ChessFactory;"]},"metadata":{},"sourceType":"module"}