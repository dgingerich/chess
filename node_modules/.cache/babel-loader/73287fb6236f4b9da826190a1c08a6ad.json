{"ast":null,"code":"import PawnFactory from \"./Pieces/Pawn\";\nimport RookFactory from \"./Pieces/Rook\";\nimport KnightFactory from \"./Pieces/Knight\";\nimport BishopFactory from \"./Pieces/Bishop\";\nimport QueenFactory from \"./Pieces/Queen\";\nimport KingFactory from \"./Pieces/King\";\n\nconst ChessFactory = () => {\n  const initializeBoard = () => {\n    return [[RookFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), RookFactory('black')], [KnightFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), KnightFactory('black')], [BishopFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), BishopFactory('black')], [QueenFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), QueenFactory('black')], [KingFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), KingFactory('black')], [BishopFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), BishopFactory('black')], [KnightFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), KnightFactory('black')], [RookFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), RookFactory('black')]];\n  }; //Generates list of moves given a board setup and the color of the current turn\n  //maybe\n  //returns True if move is successful, returns False if not successful\n\n\n  const generateMovesList = (board, turn) => {\n    let movesList = [];\n\n    for (let x = 0; x < 8; x = x + 1) {\n      for (let y = 0; y < 8; y = y + 1) {\n        if (board[x][y] !== null && board[x][y].color === turn) {\n          let position = [x, y];\n          movesList = movesList.concat(board[x][y].getMoves(board, position));\n        }\n      }\n    }\n\n    return movesList;\n  };\n\n  return Object.create({\n    board: initializeBoard(),\n    turn: 'white',\n    movesList: generateMovesList(initializeBoard(), 'white'),\n    moveHistory: [],\n\n    //generateMovesList isn't limited to current board and turn, in case a \n    generateMovesList(board, turn) {\n      return generateMovesList(board, turn);\n    },\n\n    //Move based on two positions\n    //I'll need to add functions for castling/converting pawn on end rank (should both of those go here?)\n    move(position1, position2) {\n      let moveInMovesList = false; //Check if move is in movesList\n\n      this.movesList.forEach(move => {\n        if (JSON.stringify(move) === JSON.stringify([position1, position2])) moveInMovesList = true;\n      }); //Logic if move is legal\n\n      if (moveInMovesList) {\n        //Sets position2 equal to value of position1\n        this.board[position2[0]][position2[1]] = this.board[position1[0]][position1[1]]; //Clears position1\n\n        this.board[position1[0]][position1[1]] = null; //Adds move to move history\n\n        this.moveHistory.push([position1, position2]); //Changes turn\n\n        if (this.turn === 'white') {\n          this.turn = 'black';\n        } else {\n          this.turn = 'white';\n        } //Re-generates movesList for new board and turn\n\n\n        this.movesList = generateMovesList(this.board, this.turn); //if movesList.length === 0 current turn wins\n        //if movesList contains a move that allows the king to be attacked, illegal move\n\n        return true;\n      } else {\n        return false;\n      }\n    },\n\n    printMoves() {\n      this.generateMovesList(this.board, this.turn);\n      console.log(this.movesList);\n    }\n\n  });\n};\n\n_c = ChessFactory;\nexport default ChessFactory;\n\nvar _c;\n\n$RefreshReg$(_c, \"ChessFactory\");","map":{"version":3,"sources":["C:/Users/dging/Programming/chess/src/model/Chess.js"],"names":["PawnFactory","RookFactory","KnightFactory","BishopFactory","QueenFactory","KingFactory","ChessFactory","initializeBoard","generateMovesList","board","turn","movesList","x","y","color","position","concat","getMoves","Object","create","moveHistory","move","position1","position2","moveInMovesList","forEach","JSON","stringify","push","printMoves","console","log"],"mappings":"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","sourcesContent":["import PawnFactory from \"./Pieces/Pawn\";\r\nimport RookFactory from \"./Pieces/Rook\";\r\nimport KnightFactory from \"./Pieces/Knight\";\r\nimport BishopFactory from \"./Pieces/Bishop\";\r\nimport QueenFactory from \"./Pieces/Queen\";\r\nimport KingFactory from \"./Pieces/King\";\r\n\r\nconst ChessFactory = () => {\r\n\r\n    const initializeBoard = () => {\r\n        return ([\r\n            [RookFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), RookFactory('black')],\r\n            [KnightFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), KnightFactory('black')],\r\n            [BishopFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), BishopFactory('black')],\r\n            [QueenFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), QueenFactory('black')],\r\n            [KingFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), KingFactory('black')],\r\n            [BishopFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), BishopFactory('black')],\r\n            [KnightFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), KnightFactory('black')],\r\n            [RookFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), RookFactory('black')],\r\n        ]);\r\n    };\r\n\r\n    //Generates list of moves given a board setup and the color of the current turn\r\n    //maybe\r\n    //returns True if move is successful, returns False if not successful\r\n    const generateMovesList = (board, turn) => {\r\n\r\n        let movesList = [];\r\n\r\n        for (let x = 0; x < 8; x = x + 1) {\r\n            for (let y = 0; y < 8; y = y + 1) {\r\n                if (board[x][y] !== null && board[x][y].color === turn) {\r\n                    let position = [x, y];\r\n                    movesList = movesList.concat(board[x][y].getMoves(board, position));\r\n                }\r\n            }\r\n        }\r\n\r\n        return movesList;\r\n    }\r\n\r\nreturn Object.create({\r\n    board: initializeBoard(),\r\n    turn: 'white',\r\n    movesList: generateMovesList(initializeBoard(), 'white'),\r\n    moveHistory: [],\r\n\r\n    //generateMovesList isn't limited to current board and turn, in case a \r\n    generateMovesList(board, turn) {\r\n        return generateMovesList(board, turn);\r\n    },\r\n\r\n    //Move based on two positions\r\n    //I'll need to add functions for castling/converting pawn on end rank (should both of those go here?)\r\n    move(position1, position2) {\r\n\r\n        let moveInMovesList = false;\r\n\r\n        //Check if move is in movesList\r\n        this.movesList.forEach(move => {\r\n            if (JSON.stringify(move) === JSON.stringify([position1, position2])) moveInMovesList = true;\r\n        });\r\n\r\n        //Logic if move is legal\r\n        if (moveInMovesList) {\r\n            //Sets position2 equal to value of position1\r\n            this.board[position2[0]][position2[1]] = this.board[position1[0]][position1[1]];\r\n            //Clears position1\r\n            this.board[position1[0]][position1[1]] = null;\r\n            //Adds move to move history\r\n            this.moveHistory.push([position1, position2]);\r\n            //Changes turn\r\n            if (this.turn === 'white') {\r\n                this.turn = 'black';\r\n            } else {\r\n                this.turn = 'white';\r\n            }\r\n            //Re-generates movesList for new board and turn\r\n            this.movesList = generateMovesList(this.board, this.turn);\r\n            //if movesList.length === 0 current turn wins\r\n            //if movesList contains a move that allows the king to be attacked, illegal move\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    },\r\n    printMoves() {\r\n        this.generateMovesList(this.board, this.turn);\r\n        console.log(this.movesList);\r\n    }\r\n})\r\n\r\n}\r\n\r\nexport default ChessFactory;"]},"metadata":{},"sourceType":"module"}