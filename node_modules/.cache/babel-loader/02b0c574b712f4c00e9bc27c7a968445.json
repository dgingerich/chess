{"ast":null,"code":"import PawnFactory from \"./Pieces/Pawn\";\nimport RookFactory from \"./Pieces/Rook\";\nimport KnightFactory from \"./Pieces/Knight\";\nimport BishopFactory from \"./Pieces/Bishop\";\nimport QueenFactory from \"./Pieces/Queen\";\nimport KingFactory from \"./Pieces/King\";\nimport deepCopy from \"./core/deepCopy\";\n\nconst ChessFactory = () => {\n  const initializeBoard = () => {\n    return [[RookFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), RookFactory('black')], [KnightFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), KnightFactory('black')], [BishopFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), BishopFactory('black')], [QueenFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), QueenFactory('black')], [KingFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), KingFactory('black')], [BishopFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), BishopFactory('black')], [KnightFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), KnightFactory('black')], [RookFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), RookFactory('black')]];\n  }; //Generates list of moves given a board setup and the color of the current turn\n  //Checks if player is in check after move\n\n\n  const generateImmediateMoves = (board, turn) => {\n    let movesList = [];\n\n    for (let x = 0; x < 8; x = x + 1) {\n      for (let y = 0; y < 8; y = y + 1) {\n        if (board[x][y] !== null && board[x][y].color === turn) {\n          let position = [x, y];\n          movesList = movesList.concat(board[x][y].getMoves(board, position));\n        }\n      }\n    }\n\n    return movesList;\n  }; //Generates list of legal moves, given the current turn and board\n  //Legal move takes the form of [initialPosition, finalPosition]\n\n\n  const generateLegalMovesList = (board, turn) => {\n    let legalMovesList = generateImmediateMoves(board, turn);\n    let illegalMovesList = []; //Loops through all moves and generates a new board for after each move\n    //Checks if player is in check \n    //If any of the opposing player's possible moves on the new board attack the player's king, move is illegal\n    //Adds illigal moves to illegalMovesList, then removes moves in illegalMovesList from movesList\n\n    for (let i = 0; i < legalMovesList.length; i = i + 1) {\n      let move = legalMovesList[i];\n      let resultingBoard = deepCopy(board);\n      let positionOfKingOnResultingBoard;\n      let nextTurn = turn === 'white' ? 'black' : 'white'; //resultingBoard is the board after the current move being looped has been played\n\n      resultingBoard[move[1][0]][move[1][1]] = resultingBoard[move[0][0]][move[0][1]];\n      resultingBoard[move[0][0]][move[0][1]] = null; //Gets location of current player's king on resultingBoard\n\n      for (let x = 0; x < 8; x = x + 1) {\n        for (let y = 0; y < 8; y = y + 1) {\n          if (resultingBoard[x][y] !== null && resultingBoard[x][y].color === turn && resultingBoard[x][y].piece === 'King') {\n            positionOfKingOnResultingBoard = [x, y];\n          }\n        }\n      }\n\n      let inCheck = false; //console.log(legalMovesList[i])\n      //console.log(resultingBoard)\n\n      let nextTurnMovesList = generateImmediateMoves(resultingBoard, nextTurn); //console.log(nextTurnMovesList)\n\n      nextTurnMovesList.forEach(move => {\n        if (JSON.stringify(move[1]) === JSON.stringify(positionOfKingOnResultingBoard)) inCheck = true;\n      });\n      if (inCheck) illegalMovesList.push(legalMovesList[i]);\n    }\n\n    ; //console.log('Illegal moves: ')\n    //console.log(illegalMoves)\n    //Filters movesList to only include moves that are not in illegalMovesList\n\n    legalMovesList = legalMovesList.filter(move => !illegalMovesList.includes(move));\n    return legalMovesList;\n  };\n\n  const checkForCastle = board => {//let legalCastlingMoves=[];\n    //Check if A rook has moved\n    //Check if B rook has moved\n    //Check if King has moved\n    //if (!kingMoved && !AFileRookMoved)\n    //    let squaresKingGoesThrough = []\n    //    if no positions between them have a piece\n    //      otherTurnMoves = generateImmediateMoves(board, !turn);\n    //      let anyKingSquaresInCheck = false;\n    //          otherTurnMoves.forEach(move => {\n    //              squaresKingGoesThrough.forEach(squareKingGoesThrough => {\n    //                  if (JSON.stringify(move[1]) === squareKingGoesThrough) anyKingSquaresInCheck = true;\n    //              });\n    //          });\n    //      if (anyKingSquaresInCheck === false) legalCastlingMoves.push(thisCastlingMove)\n    //if (!kingMoved && !BFileRookMoved)\n  }; //Checks if move is in list of legal moves\n\n\n  const moveIsInMovesList = (position1, position2, movesList) => {\n    let moveInMovesList = false;\n    movesList.forEach(move => {\n      if (JSON.stringify(move) === JSON.stringify([position1, position2])) moveInMovesList = true;\n    });\n    return moveInMovesList;\n  }; //Makes move on board, adds move to history\n\n\n  const move = (position1, position2, board) => {\n    //Sets position2 equal to value of position1\n    board[position2[0]][position2[1]] = board[position1[0]][position1[1]]; //Clears position1\n\n    board[position1[0]][position1[1]] = null;\n  };\n\n  const endGame = turn => {\n    alert('End Game');\n  };\n\n  return Object.create({\n    board: initializeBoard(),\n    turn: 'white',\n    legalMovesList: generateImmediateMoves(initializeBoard(), 'white'),\n    moveHistory: [],\n\n    //I'll need to add functions for castling/converting pawn on end rank (should both of those go here?)\n    handleMove(position1, position2) {\n      //If move is in list of legal moves\n      if (moveIsInMovesList(position1, position2, this.legalMovesList)) {\n        //Makes move on board\n        move(position1, position2, this.board, this.moveHistory); //Adds move to move history\n\n        this.moveHistory.push([position1, position2]); //Changes turn\n\n        this.turn === 'white' ? this.turn = 'black' : this.turn = 'white'; //Re-generates movesList for new board and turn\n\n        this.legalMovesList = generateLegalMovesList(this.board, this.turn); //if there are no legal moves, the turn at the beginning of the function wins\n\n        if (this.legalMovesList.length === 0) endGame();\n      }\n    },\n\n    printMoves() {\n      this.generateLegalMovesList(this.board, this.turn);\n      console.log(this.legalMovesList);\n    }\n\n  });\n};\n\n_c = ChessFactory;\nexport default ChessFactory;\n\nvar _c;\n\n$RefreshReg$(_c, \"ChessFactory\");","map":{"version":3,"sources":["C:/Users/dging/Programming/chess/src/model/Chess.js"],"names":["PawnFactory","RookFactory","KnightFactory","BishopFactory","QueenFactory","KingFactory","deepCopy","ChessFactory","initializeBoard","generateImmediateMoves","board","turn","movesList","x","y","color","position","concat","getMoves","generateLegalMovesList","legalMovesList","illegalMovesList","i","length","move","resultingBoard","positionOfKingOnResultingBoard","nextTurn","piece","inCheck","nextTurnMovesList","forEach","JSON","stringify","push","filter","includes","checkForCastle","moveIsInMovesList","position1","position2","moveInMovesList","endGame","alert","Object","create","moveHistory","handleMove","printMoves","console","log"],"mappings":"AAAA,OAAOA,WAAP,MAAwB,eAAxB;AACA,OAAOC,WAAP,MAAwB,eAAxB;AACA,OAAOC,aAAP,MAA0B,iBAA1B;AACA,OAAOC,aAAP,MAA0B,iBAA1B;AACA,OAAOC,YAAP,MAAyB,gBAAzB;AACA,OAAOC,WAAP,MAAwB,eAAxB;AACA,OAAOC,QAAP,MAAqB,iBAArB;;AAEA,MAAMC,YAAY,GAAG,MAAM;AAEvB,QAAMC,eAAe,GAAG,MAAM;AAC1B,WAAQ,CACJ,CAACP,WAAW,CAAC,OAAD,CAAZ,EAAuBD,WAAW,CAAC,OAAD,CAAlC,EAA6C,IAA7C,EAAmD,IAAnD,EAAyD,IAAzD,EAA+D,IAA/D,EAAqEA,WAAW,CAAC,OAAD,CAAhF,EAA2FC,WAAW,CAAC,OAAD,CAAtG,CADI,EAEJ,CAACC,aAAa,CAAC,OAAD,CAAd,EAAyBF,WAAW,CAAC,OAAD,CAApC,EAA+C,IAA/C,EAAqD,IAArD,EAA2D,IAA3D,EAAiE,IAAjE,EAAuEA,WAAW,CAAC,OAAD,CAAlF,EAA6FE,aAAa,CAAC,OAAD,CAA1G,CAFI,EAGJ,CAACC,aAAa,CAAC,OAAD,CAAd,EAAyBH,WAAW,CAAC,OAAD,CAApC,EAA+C,IAA/C,EAAqD,IAArD,EAA2D,IAA3D,EAAiE,IAAjE,EAAuEA,WAAW,CAAC,OAAD,CAAlF,EAA6FG,aAAa,CAAC,OAAD,CAA1G,CAHI,EAIJ,CAACC,YAAY,CAAC,OAAD,CAAb,EAAwBJ,WAAW,CAAC,OAAD,CAAnC,EAA8C,IAA9C,EAAoD,IAApD,EAA0D,IAA1D,EAAgE,IAAhE,EAAsEA,WAAW,CAAC,OAAD,CAAjF,EAA4FI,YAAY,CAAC,OAAD,CAAxG,CAJI,EAKJ,CAACC,WAAW,CAAC,OAAD,CAAZ,EAAuBL,WAAW,CAAC,OAAD,CAAlC,EAA6C,IAA7C,EAAmD,IAAnD,EAAyD,IAAzD,EAA+D,IAA/D,EAAqEA,WAAW,CAAC,OAAD,CAAhF,EAA2FK,WAAW,CAAC,OAAD,CAAtG,CALI,EAMJ,CAACF,aAAa,CAAC,OAAD,CAAd,EAAyBH,WAAW,CAAC,OAAD,CAApC,EAA+C,IAA/C,EAAqD,IAArD,EAA2D,IAA3D,EAAiE,IAAjE,EAAuEA,WAAW,CAAC,OAAD,CAAlF,EAA6FG,aAAa,CAAC,OAAD,CAA1G,CANI,EAOJ,CAACD,aAAa,CAAC,OAAD,CAAd,EAAyBF,WAAW,CAAC,OAAD,CAApC,EAA+C,IAA/C,EAAqD,IAArD,EAA2D,IAA3D,EAAiE,IAAjE,EAAuEA,WAAW,CAAC,OAAD,CAAlF,EAA6FE,aAAa,CAAC,OAAD,CAA1G,CAPI,EAQJ,CAACD,WAAW,CAAC,OAAD,CAAZ,EAAuBD,WAAW,CAAC,OAAD,CAAlC,EAA6C,IAA7C,EAAmD,IAAnD,EAAyD,IAAzD,EAA+D,IAA/D,EAAqEA,WAAW,CAAC,OAAD,CAAhF,EAA2FC,WAAW,CAAC,OAAD,CAAtG,CARI,CAAR;AAUH,GAXD,CAFuB,CAevB;AACA;;;AACA,QAAMQ,sBAAsB,GAAG,CAACC,KAAD,EAAQC,IAAR,KAAiB;AAE5C,QAAIC,SAAS,GAAG,EAAhB;;AAEA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,CAApB,EAAuBA,CAAC,GAAGA,CAAC,GAAG,CAA/B,EAAkC;AAC9B,WAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,CAApB,EAAuBA,CAAC,GAAGA,CAAC,GAAG,CAA/B,EAAkC;AAC9B,YAAIJ,KAAK,CAACG,CAAD,CAAL,CAASC,CAAT,MAAgB,IAAhB,IAAwBJ,KAAK,CAACG,CAAD,CAAL,CAASC,CAAT,EAAYC,KAAZ,KAAsBJ,IAAlD,EAAwD;AACpD,cAAIK,QAAQ,GAAG,CAACH,CAAD,EAAIC,CAAJ,CAAf;AACAF,UAAAA,SAAS,GAAGA,SAAS,CAACK,MAAV,CAAiBP,KAAK,CAACG,CAAD,CAAL,CAASC,CAAT,EAAYI,QAAZ,CAAqBR,KAArB,EAA4BM,QAA5B,CAAjB,CAAZ;AACH;AACJ;AACJ;;AAED,WAAOJ,SAAP;AACH,GAdD,CAjBuB,CAiCvB;AACA;;;AACA,QAAMO,sBAAsB,GAAG,CAACT,KAAD,EAAQC,IAAR,KAAiB;AAC5C,QAAIS,cAAc,GAAGX,sBAAsB,CAACC,KAAD,EAAQC,IAAR,CAA3C;AAEA,QAAIU,gBAAgB,GAAG,EAAvB,CAH4C,CAK5C;AACA;AACA;AACA;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,cAAc,CAACG,MAAnC,EAA2CD,CAAC,GAAGA,CAAC,GAAG,CAAnD,EAAsD;AAClD,UAAIE,IAAI,GAAGJ,cAAc,CAACE,CAAD,CAAzB;AACA,UAAIG,cAAc,GAAGnB,QAAQ,CAACI,KAAD,CAA7B;AACA,UAAIgB,8BAAJ;AACA,UAAIC,QAAQ,GAAIhB,IAAI,KAAK,OAAV,GAAqB,OAArB,GAA+B,OAA9C,CAJkD,CAMlD;;AACAc,MAAAA,cAAc,CAACD,IAAI,CAAC,CAAD,CAAJ,CAAQ,CAAR,CAAD,CAAd,CAA2BA,IAAI,CAAC,CAAD,CAAJ,CAAQ,CAAR,CAA3B,IAAyCC,cAAc,CAACD,IAAI,CAAC,CAAD,CAAJ,CAAQ,CAAR,CAAD,CAAd,CAA2BA,IAAI,CAAC,CAAD,CAAJ,CAAQ,CAAR,CAA3B,CAAzC;AACAC,MAAAA,cAAc,CAACD,IAAI,CAAC,CAAD,CAAJ,CAAQ,CAAR,CAAD,CAAd,CAA2BA,IAAI,CAAC,CAAD,CAAJ,CAAQ,CAAR,CAA3B,IAAyC,IAAzC,CARkD,CAUlD;;AACA,WAAK,IAAIX,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,CAApB,EAAuBA,CAAC,GAAGA,CAAC,GAAG,CAA/B,EAAkC;AAC9B,aAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,CAApB,EAAuBA,CAAC,GAAGA,CAAC,GAAG,CAA/B,EAAkC;AAC9B,cAAIW,cAAc,CAACZ,CAAD,CAAd,CAAkBC,CAAlB,MAAyB,IAAzB,IAAiCW,cAAc,CAACZ,CAAD,CAAd,CAAkBC,CAAlB,EAAqBC,KAArB,KAA+BJ,IAAhE,IAAwEc,cAAc,CAACZ,CAAD,CAAd,CAAkBC,CAAlB,EAAqBc,KAArB,KAA+B,MAA3G,EAAmH;AAC/GF,YAAAA,8BAA8B,GAAG,CAACb,CAAD,EAAIC,CAAJ,CAAjC;AACH;AACJ;AACJ;;AAED,UAAIe,OAAO,GAAG,KAAd,CAnBkD,CAoBlD;AACA;;AACA,UAAIC,iBAAiB,GAAGrB,sBAAsB,CAACgB,cAAD,EAAiBE,QAAjB,CAA9C,CAtBkD,CAuBlD;;AAEAG,MAAAA,iBAAiB,CAACC,OAAlB,CAA0BP,IAAI,IAAI;AAC9B,YAAIQ,IAAI,CAACC,SAAL,CAAeT,IAAI,CAAC,CAAD,CAAnB,MAA4BQ,IAAI,CAACC,SAAL,CAAeP,8BAAf,CAAhC,EAAgFG,OAAO,GAAG,IAAV;AACnF,OAFD;AAIA,UAAIA,OAAJ,EAAaR,gBAAgB,CAACa,IAAjB,CAAsBd,cAAc,CAACE,CAAD,CAApC;AAEhB;;AAAA,KAxC2C,CAyC5C;AACA;AAEA;;AACAF,IAAAA,cAAc,GAAGA,cAAc,CAACe,MAAf,CAAuBX,IAAD,IAAU,CAACH,gBAAgB,CAACe,QAAjB,CAA0BZ,IAA1B,CAAjC,CAAjB;AAIA,WAAOJ,cAAP;AACH,GAlDD;;AAoDA,QAAMiB,cAAc,GAAI3B,KAAD,IAAa,CAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACH,GAlBD,CAvFuB,CA2GvB;;;AACA,QAAM4B,iBAAiB,GAAG,CAACC,SAAD,EAAYC,SAAZ,EAAuB5B,SAAvB,KAAqC;AAE3D,QAAI6B,eAAe,GAAG,KAAtB;AAEA7B,IAAAA,SAAS,CAACmB,OAAV,CAAkBP,IAAI,IAAI;AACtB,UAAIQ,IAAI,CAACC,SAAL,CAAeT,IAAf,MAAyBQ,IAAI,CAACC,SAAL,CAAe,CAACM,SAAD,EAAYC,SAAZ,CAAf,CAA7B,EAAqEC,eAAe,GAAG,IAAlB;AACxE,KAFD;AAIA,WAAOA,eAAP;AACH,GATD,CA5GuB,CAuHvB;;;AACA,QAAMjB,IAAI,GAAG,CAACe,SAAD,EAAYC,SAAZ,EAAuB9B,KAAvB,KAAiC;AAC1C;AACAA,IAAAA,KAAK,CAAC8B,SAAS,CAAC,CAAD,CAAV,CAAL,CAAoBA,SAAS,CAAC,CAAD,CAA7B,IAAoC9B,KAAK,CAAC6B,SAAS,CAAC,CAAD,CAAV,CAAL,CAAoBA,SAAS,CAAC,CAAD,CAA7B,CAApC,CAF0C,CAG1C;;AACA7B,IAAAA,KAAK,CAAC6B,SAAS,CAAC,CAAD,CAAV,CAAL,CAAoBA,SAAS,CAAC,CAAD,CAA7B,IAAoC,IAApC;AACH,GALD;;AAOA,QAAMG,OAAO,GAAI/B,IAAD,IAAU;AACtBgC,IAAAA,KAAK,CAAC,UAAD,CAAL;AACH,GAFD;;AAIA,SAAOC,MAAM,CAACC,MAAP,CAAc;AACjBnC,IAAAA,KAAK,EAAEF,eAAe,EADL;AAEjBG,IAAAA,IAAI,EAAE,OAFW;AAGjBS,IAAAA,cAAc,EAAEX,sBAAsB,CAACD,eAAe,EAAhB,EAAoB,OAApB,CAHrB;AAIjBsC,IAAAA,WAAW,EAAE,EAJI;;AAMjB;AACAC,IAAAA,UAAU,CAACR,SAAD,EAAYC,SAAZ,EAAuB;AAE7B;AACA,UAAIF,iBAAiB,CAACC,SAAD,EAAYC,SAAZ,EAAuB,KAAKpB,cAA5B,CAArB,EAAkE;AAC9D;AACAI,QAAAA,IAAI,CAACe,SAAD,EAAYC,SAAZ,EAAuB,KAAK9B,KAA5B,EAAmC,KAAKoC,WAAxC,CAAJ,CAF8D,CAI9D;;AACA,aAAKA,WAAL,CAAiBZ,IAAjB,CAAsB,CAACK,SAAD,EAAYC,SAAZ,CAAtB,EAL8D,CAO9D;;AACA,aAAK7B,IAAL,KAAc,OAAd,GAAwB,KAAKA,IAAL,GAAY,OAApC,GAA8C,KAAKA,IAAL,GAAY,OAA1D,CAR8D,CAU9D;;AACA,aAAKS,cAAL,GAAsBD,sBAAsB,CAAC,KAAKT,KAAN,EAAa,KAAKC,IAAlB,CAA5C,CAX8D,CAa9D;;AACA,YAAI,KAAKS,cAAL,CAAoBG,MAApB,KAA+B,CAAnC,EAAsCmB,OAAO;AAChD;AACJ,KA1BgB;;AA2BjBM,IAAAA,UAAU,GAAG;AACT,WAAK7B,sBAAL,CAA4B,KAAKT,KAAjC,EAAwC,KAAKC,IAA7C;AACAsC,MAAAA,OAAO,CAACC,GAAR,CAAY,KAAK9B,cAAjB;AACH;;AA9BgB,GAAd,CAAP;AAiCH,CApKD;;KAAMb,Y;AAsKN,eAAeA,YAAf","sourcesContent":["import PawnFactory from \"./Pieces/Pawn\";\r\nimport RookFactory from \"./Pieces/Rook\";\r\nimport KnightFactory from \"./Pieces/Knight\";\r\nimport BishopFactory from \"./Pieces/Bishop\";\r\nimport QueenFactory from \"./Pieces/Queen\";\r\nimport KingFactory from \"./Pieces/King\";\r\nimport deepCopy from \"./core/deepCopy\";\r\n\r\nconst ChessFactory = () => {\r\n\r\n    const initializeBoard = () => {\r\n        return ([\r\n            [RookFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), RookFactory('black')],\r\n            [KnightFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), KnightFactory('black')],\r\n            [BishopFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), BishopFactory('black')],\r\n            [QueenFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), QueenFactory('black')],\r\n            [KingFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), KingFactory('black')],\r\n            [BishopFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), BishopFactory('black')],\r\n            [KnightFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), KnightFactory('black')],\r\n            [RookFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), RookFactory('black')],\r\n        ]);\r\n    };\r\n\r\n    //Generates list of moves given a board setup and the color of the current turn\r\n    //Checks if player is in check after move\r\n    const generateImmediateMoves = (board, turn) => {\r\n\r\n        let movesList = [];\r\n\r\n        for (let x = 0; x < 8; x = x + 1) {\r\n            for (let y = 0; y < 8; y = y + 1) {\r\n                if (board[x][y] !== null && board[x][y].color === turn) {\r\n                    let position = [x, y];\r\n                    movesList = movesList.concat(board[x][y].getMoves(board, position));\r\n                }\r\n            }\r\n        }\r\n\r\n        return movesList;\r\n    }\r\n\r\n    //Generates list of legal moves, given the current turn and board\r\n    //Legal move takes the form of [initialPosition, finalPosition]\r\n    const generateLegalMovesList = (board, turn) => {\r\n        let legalMovesList = generateImmediateMoves(board, turn);\r\n\r\n        let illegalMovesList = [];\r\n\r\n        //Loops through all moves and generates a new board for after each move\r\n        //Checks if player is in check \r\n        //If any of the opposing player's possible moves on the new board attack the player's king, move is illegal\r\n        //Adds illigal moves to illegalMovesList, then removes moves in illegalMovesList from movesList\r\n        for (let i = 0; i < legalMovesList.length; i = i + 1) {\r\n            let move = legalMovesList[i];\r\n            let resultingBoard = deepCopy(board);\r\n            let positionOfKingOnResultingBoard;\r\n            let nextTurn = (turn === 'white') ? 'black' : 'white';\r\n\r\n            //resultingBoard is the board after the current move being looped has been played\r\n            resultingBoard[move[1][0]][move[1][1]] = resultingBoard[move[0][0]][move[0][1]];\r\n            resultingBoard[move[0][0]][move[0][1]] = null;\r\n\r\n            //Gets location of current player's king on resultingBoard\r\n            for (let x = 0; x < 8; x = x + 1) {\r\n                for (let y = 0; y < 8; y = y + 1) {\r\n                    if (resultingBoard[x][y] !== null && resultingBoard[x][y].color === turn && resultingBoard[x][y].piece === 'King') {\r\n                        positionOfKingOnResultingBoard = [x, y];\r\n                    }\r\n                }\r\n            }\r\n\r\n            let inCheck = false;\r\n            //console.log(legalMovesList[i])\r\n            //console.log(resultingBoard)\r\n            let nextTurnMovesList = generateImmediateMoves(resultingBoard, nextTurn);\r\n            //console.log(nextTurnMovesList)\r\n\r\n            nextTurnMovesList.forEach(move => {\r\n                if (JSON.stringify(move[1]) === JSON.stringify(positionOfKingOnResultingBoard)) inCheck = true;\r\n            });\r\n\r\n            if (inCheck) illegalMovesList.push(legalMovesList[i]);\r\n\r\n        };\r\n        //console.log('Illegal moves: ')\r\n        //console.log(illegalMoves)\r\n\r\n        //Filters movesList to only include moves that are not in illegalMovesList\r\n        legalMovesList = legalMovesList.filter((move) => !illegalMovesList.includes(move));\r\n\r\n\r\n\r\n        return legalMovesList\r\n    }\r\n\r\n    const checkForCastle = (board, ) => {\r\n\r\n        //let legalCastlingMoves=[];\r\n        //Check if A rook has moved\r\n        //Check if B rook has moved\r\n        //Check if King has moved\r\n        //if (!kingMoved && !AFileRookMoved)\r\n        //    let squaresKingGoesThrough = []\r\n        //    if no positions between them have a piece\r\n        //      otherTurnMoves = generateImmediateMoves(board, !turn);\r\n        //      let anyKingSquaresInCheck = false;\r\n        //          otherTurnMoves.forEach(move => {\r\n        //              squaresKingGoesThrough.forEach(squareKingGoesThrough => {\r\n        //                  if (JSON.stringify(move[1]) === squareKingGoesThrough) anyKingSquaresInCheck = true;\r\n        //              });\r\n        //          });\r\n        //      if (anyKingSquaresInCheck === false) legalCastlingMoves.push(thisCastlingMove)\r\n        //if (!kingMoved && !BFileRookMoved)\r\n    }\r\n\r\n    //Checks if move is in list of legal moves\r\n    const moveIsInMovesList = (position1, position2, movesList) => {\r\n\r\n        let moveInMovesList = false;\r\n\r\n        movesList.forEach(move => {\r\n            if (JSON.stringify(move) === JSON.stringify([position1, position2])) moveInMovesList = true;\r\n        });\r\n        \r\n        return moveInMovesList;\r\n    }\r\n\r\n    //Makes move on board, adds move to history\r\n    const move = (position1, position2, board) => {\r\n        //Sets position2 equal to value of position1\r\n        board[position2[0]][position2[1]] = board[position1[0]][position1[1]];\r\n        //Clears position1\r\n        board[position1[0]][position1[1]] = null;\r\n    }\r\n\r\n    const endGame = (turn) => {\r\n        alert('End Game')\r\n    }\r\n\r\n    return Object.create({\r\n        board: initializeBoard(),\r\n        turn: 'white',\r\n        legalMovesList: generateImmediateMoves(initializeBoard(), 'white'),\r\n        moveHistory: [],\r\n\r\n        //I'll need to add functions for castling/converting pawn on end rank (should both of those go here?)\r\n        handleMove(position1, position2) {\r\n\r\n            //If move is in list of legal moves\r\n            if (moveIsInMovesList(position1, position2, this.legalMovesList)) {\r\n                //Makes move on board\r\n                move(position1, position2, this.board, this.moveHistory);\r\n\r\n                //Adds move to move history\r\n                this.moveHistory.push([position1, position2]);\r\n\r\n                //Changes turn\r\n                this.turn === 'white' ? this.turn = 'black' : this.turn = 'white';\r\n\r\n                //Re-generates movesList for new board and turn\r\n                this.legalMovesList = generateLegalMovesList(this.board, this.turn);\r\n\r\n                //if there are no legal moves, the turn at the beginning of the function wins\r\n                if (this.legalMovesList.length === 0) endGame();\r\n            }\r\n        },\r\n        printMoves() {\r\n            this.generateLegalMovesList(this.board, this.turn);\r\n            console.log(this.legalMovesList);\r\n        }\r\n    })\r\n\r\n}\r\n\r\nexport default ChessFactory;"]},"metadata":{},"sourceType":"module"}