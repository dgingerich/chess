{"ast":null,"code":"import PawnFactory from \"./Pieces/Pawn\";\nimport RookFactory from \"./Pieces/Rook\";\nimport KnightFactory from \"./Pieces/Knight\";\nimport BishopFactory from \"./Pieces/Bishop\";\nimport QueenFactory from \"./Pieces/Queen\";\nimport KingFactory from \"./Pieces/King\";\nimport deepCopy from \"./core/deepCopy\";\n\nconst ChessFactory = () => {\n  const initializeBoard = () => {\n    return [[RookFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), RookFactory('black')], [KnightFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), KnightFactory('black')], [BishopFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), BishopFactory('black')], [QueenFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), QueenFactory('black')], [KingFactory('white'), PawnFactory('white'), null, null, PawnFactory('white'), null, PawnFactory('black'), KingFactory('black')], [BishopFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), BishopFactory('black')], [KnightFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), KnightFactory('black')], [RookFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), RookFactory('black')]];\n  }; //Generates list of moves given a board setup and the color of the current turn\n  //Checks if player is in check after move\n\n\n  const generateImmediateMoves = (board, turn) => {\n    let movesList = [];\n\n    for (let x = 0; x < 8; x = x + 1) {\n      for (let y = 0; y < 8; y = y + 1) {\n        if (board[x][y] !== null && board[x][y].color === turn) {\n          let position = [x, y];\n          movesList = movesList.concat(board[x][y].getMoves(board, position));\n        }\n      }\n    }\n\n    return movesList;\n  }; //Generates list of legal moves, given the current turn and board\n  //Legal move takes the form of [initialPosition, finalPosition]\n\n\n  const generateLegalMovesList = (board, turn, moveHistory) => {\n    let legalMovesList = generateImmediateMoves(board, turn);\n    let illegalMovesList = []; //Adds castling moves\n\n    checkForCastle(board, turn, moveHistory).forEach(castleMove => {\n      if (castleMove.length > 0) legalMovesList.push(castleMove);\n    });\n    checkForEnPassant(board, turn, moveHistory).forEach(enPassantMove => {\n      if (enPassantMove.length > 0) legalMovesList.push(enPassantMove);\n    }); //Loops through all moves and generates a new board for after each move\n    //Checks if player is in check \n    //If any of the opposing player's possible moves on the new board attack the player's king, move is illegal\n    //Adds illigal moves to illegalMovesList, then removes moves in illegalMovesList from movesList\n\n    for (let i = 0; i < legalMovesList.length; i = i + 1) {\n      let possibleMove = legalMovesList[i];\n      let resultingBoard = deepCopy(board);\n      let positionOfKingOnResultingBoard;\n      let nextTurn = turn === 'white' ? 'black' : 'white'; //resultingBoard is the board after the current move being looped has been played\n      //resultingBoard[move[1][0]][move[1][1]] = resultingBoard[move[0][0]][move[0][1]];\n      //resultingBoard[move[0][0]][move[0][1]] = null;\n\n      if (typeof possibleMove[0] === 'string') {\n        move(possibleMove[0], possibleMove[1][0], possibleMove[1][1], resultingBoard);\n      } else {\n        move('normal', possibleMove[0], possibleMove[1], resultingBoard);\n      } //Gets location of current player's king on resultingBoard\n\n\n      for (let x = 0; x < 8; x = x + 1) {\n        for (let y = 0; y < 8; y = y + 1) {\n          if (resultingBoard[x][y] !== null && resultingBoard[x][y].color === turn && resultingBoard[x][y].piece === 'King') {\n            positionOfKingOnResultingBoard = [x, y];\n          }\n        }\n      }\n\n      let inCheck = false;\n      let nextTurnMovesList = generateImmediateMoves(resultingBoard, nextTurn);\n      nextTurnMovesList.forEach(move => {\n        if (JSON.stringify(move[1]) === JSON.stringify(positionOfKingOnResultingBoard)) inCheck = true;\n      });\n      if (inCheck) illegalMovesList.push(legalMovesList[i]);\n    }\n\n    ; //Filters movesList to only include moves that are not in illegalMovesList\n\n    legalMovesList = legalMovesList.filter(move => !illegalMovesList.includes(move));\n    return legalMovesList;\n  }; //Checks if there are any castling moves\n\n\n  const checkForCastle = (board, turn, moveHistory) => {\n    let legalCastlingMoves = [];\n    let ARookInitialPosition = turn === 'white' ? [0, 0] : [0, 7];\n    let HRookInitialPosition = turn === 'white' ? [7, 0] : [7, 7];\n    let kingInitialPosition = turn === 'white' ? [4, 0] : [4, 7]; //King castling long\n\n    if (castleMoveLegal(kingInitialPosition, ARookInitialPosition, board, turn, moveHistory)) {\n      legalCastlingMoves.push( //2D move. First is king, second is rook\n      ['castle', [kingInitialPosition, [kingInitialPosition[0] - 2, kingInitialPosition[1]]], [ARookInitialPosition, [ARookInitialPosition[0] + 3, ARookInitialPosition[1]]]]);\n    } //King castling short\n\n\n    if (castleMoveLegal(kingInitialPosition, HRookInitialPosition, board, turn, moveHistory)) {\n      legalCastlingMoves.push( //2D move. First is king, second is rook\n      ['castle', [kingInitialPosition, [kingInitialPosition[0] + 2, kingInitialPosition[1]]], [HRookInitialPosition, [HRookInitialPosition[0] - 2, ARookInitialPosition[1]]]]);\n    }\n\n    return legalCastlingMoves;\n  }; //Checks if castling move is legal, given rook/king pair to castle\n\n\n  const castleMoveLegal = (kingInitialPosition, rookInitialPosition, board, turn, moveHistory) => {\n    let kingHasMoved = hasPieceMoved(kingInitialPosition, moveHistory);\n    let rookHasMoved = hasPieceMoved(rookInitialPosition, moveHistory);\n\n    if (!kingHasMoved && !rookHasMoved) {\n      let squaresKingGoesThrough = []; //Are there pieces between king and rook?\n\n      let squaresBetweenOccupied = false; //Loops through all squares between x value of king's initial position and rook's initial position\n\n      for (let x = kingInitialPosition[0] > rookInitialPosition[0] ? kingInitialPosition[0] - 1 : rookInitialPosition[0] - 1; x !== 4 && x !== 0; x = x - 1) {\n        //King moves two squares. If square is within 2 of king initial square, push to squaresKingGoesThrough\n        if (Math.abs(kingInitialPosition[0] - x) <= 2) squaresKingGoesThrough.push([x, kingInitialPosition[1]]); //If square has a piece, the squares between are occupied\n\n        if (board[x][kingInitialPosition[1]] !== null) squaresBetweenOccupied = true;\n      } //if no positions between them have a piece, check if any squares the king passes are in check\n\n\n      if (!squaresBetweenOccupied) {\n        //Generates other player's moves\n        let otherTurnMoves = generateImmediateMoves(board, turn === 'white' ? 'black' : 'white');\n        let anyKingSquaresInCheck = false;\n        otherTurnMoves.forEach(move => {\n          squaresKingGoesThrough.forEach(squareKingGoesThrough => {\n            if (JSON.stringify(move[1]) === JSON.stringify(squareKingGoesThrough)) anyKingSquaresInCheck = true;\n          });\n        }); //Only returns true if 1) no pieces are between and 2) no squares the king goes through are in check\n        //Already checked for no pieces between, so returns value of statement \"no squares the king goes through are in check\"\n\n        return anyKingSquaresInCheck === false;\n      }\n    } else {\n      return false;\n    } //Need logic to handle castling moves in legalMovesList\n    //Probably just if any move is a 2d array, both moves are made\n    //Since castling should really only be the only move with two moves\n    //Unless pawn promotion also has two moves? \n\n  }; //Checks if there are any en passant moves\n\n\n  const checkForEnPassant = (board, turn, moveHistory) => {\n    let possibleEnPassantMoves = []; //Y value pawns can en passant from, depending on piece color\n\n    let y = turn === 'white' ? 4 : 3; //for each pawn\n\n    for (let x = 0; x < 8; x = x + 1) {\n      if (board[x][y] !== null && board[x][y].piece === 'Pawn' && board[x][y].color === turn) {\n        let opposingColorPawnInitialRank = turn === 'white' ? 6 : 1; //if the square is occupied by a pawn of the opposing color\n\n        if (x + 1 < 8 && board[x + 1][y] !== null && board[x + 1][y].piece === 'Pawn' && board[x + 1][y].color !== turn) {\n          //First checks if the last move started on back rank, second checks if the last move ended next to the piece\n          if (moveHistory[moveHistory.length - 1][0][1] === opposingColorPawnInitialRank && moveHistory[moveHistory.length - 1][1][0] === x + 1 && moveHistory[moveHistory.length - 1][1][1] === y) {\n            //don't have to worry about a piece being in the spot, because the most recent pawn move passed over it\n            let newY = turn === 'white' ? 5 : 2;\n            possibleEnPassantMoves.push('en passant', [[x, y], [x + 1, newY]]);\n          }\n        } else if (x - 1 > 0 && board[x - 1][y] !== null && board[x - 1][y].piece === 'Pawn' && board[x - 1][y].color !== turn) {\n          if (moveHistory[moveHistory.length - 1][0][1] === opposingColorPawnInitialRank && moveHistory[moveHistory.length - 1][1][0] === x - 1 && moveHistory[moveHistory.length - 1][1][1] === y) {\n            //don't have to worry about a piece being in the spot, because the most recent pawn move passed over it\n            let newY = turn === 'white' ? 5 : 2;\n            possibleEnPassantMoves.push('en passant', [[x, y], [x - 1, newY]]);\n          }\n        }\n      }\n    }\n\n    return possibleEnPassantMoves;\n  }; //Checks if piece has moved, given initial position and history of moves\n\n\n  const hasPieceMoved = (initialPosition, moveHistory) => {\n    let hasMoved = false;\n    moveHistory.forEach(move => {\n      if (JSON.stringify(move[0]) === JSON.stringify(initialPosition)) hasMoved = true;\n    });\n    return hasMoved;\n  }; //Checks if move is in list of legal moves\n  //Returns string. String can be 'invalid', 'normal', 'castle', 'en passant'\n\n\n  const moveIsInMovesList = (position1, position2, movesList) => {\n    let moveInMovesList = 'invalid';\n    movesList.forEach(move => {\n      if (JSON.stringify(move) === JSON.stringify([position1, position2])) moveInMovesList = 'normal'; //Checks for castling or en passant, which are 2D arrays\n      //Type of move is stored at move[0]\n\n      if (typeof move[0] === 'string' && JSON.stringify(move[1]) === JSON.stringify([position1, position2])) moveInMovesList = move[0];\n    });\n    return moveInMovesList;\n  }; //Makes move on board, adds move to history\n\n\n  const move = (moveType, position1, position2, board) => {\n    console.log(moveType);\n\n    switch (moveType) {\n      case 'normal':\n        //Sets position2 equal to value of position1\n        board[position2[0]][position2[1]] = board[position1[0]][position1[1]]; //Clears position1\n\n        board[position1[0]][position1[1]] = null;\n        break;\n\n      case 'castle':\n        //Moves king\n        board[position2[0]][position2[1]] = board[position1[0]][position1[1]]; //Set original king position to null\n\n        board[position1[0]][position1[1]] = null; //Move rooks based on side castling to (found based on position2[0], which gives column king moves to)\n        //Position2[1] will always give the row\n        //Castle long\n\n        if (position2[0] === 2) {\n          //Moves rook\n          board[3][position2[1]] = board[0][position2[1]]; //Sets rook initial position to null\n\n          board[0][position2[1]] = null;\n        } //Castle short\n        else {\n          //Moves rook\n          board[5][position2[1]] = board[7][position2[1]]; //Sets rook initial position to null\n\n          board[7][position2[1]] = null;\n        }\n\n        break;\n\n      case 'en passant':\n        console.log(position2[1]);\n        let yIncrement = position1[1] === 4 ? -1 : 1;\n        console.log(yIncrement);\n        board[position2[0]][position2[1]] = board[position1[0]][position1[1]];\n        board[position1[0]][position1[1]] = null;\n        console.log(`${position2[0]}, ${position2[1] + yIncrement}`);\n        board[position2[0]][position2[1] + yIncrement] = null;\n        break;\n\n      default:\n        break;\n    }\n  };\n\n  const endGame = turn => {\n    alert('End Game');\n  };\n\n  return Object.create({\n    board: initializeBoard(),\n    turn: 'white',\n    legalMovesList: generateImmediateMoves(initializeBoard(), 'white'),\n    moveHistory: [],\n\n    //I'll need to add functions for castling/converting pawn on end rank (should both of those go here?)\n    handleMove(position1, position2) {\n      let moveType = moveIsInMovesList(position1, position2, this.legalMovesList); //If move is in list of legal moves\n\n      if (moveType !== 'invalid') {\n        //Makes move on board\n        move(moveType, position1, position2, this.board, this.moveHistory); //Adds move to move history\n\n        this.moveHistory.push([position1, position2]); //Changes turn\n\n        this.turn === 'white' ? this.turn = 'black' : this.turn = 'white'; //Re-generates movesList for new board and turn\n\n        this.legalMovesList = generateLegalMovesList(this.board, this.turn, this.moveHistory); //if there are no legal moves, the turn at the beginning of the function wins\n\n        if (this.legalMovesList.length === 0) endGame();\n      }\n    },\n\n    printMoves() {\n      this.generateLegalMovesList(this.board, this.turn);\n      console.log(this.legalMovesList);\n    }\n\n  });\n};\n\n_c = ChessFactory;\nexport default ChessFactory;\n\nvar _c;\n\n$RefreshReg$(_c, \"ChessFactory\");","map":{"version":3,"sources":["C:/Users/dging/Programming/chess/src/model/Chess.js"],"names":["PawnFactory","RookFactory","KnightFactory","BishopFactory","QueenFactory","KingFactory","deepCopy","ChessFactory","initializeBoard","generateImmediateMoves","board","turn","movesList","x","y","color","position","concat","getMoves","generateLegalMovesList","moveHistory","legalMovesList","illegalMovesList","checkForCastle","forEach","castleMove","length","push","checkForEnPassant","enPassantMove","i","possibleMove","resultingBoard","positionOfKingOnResultingBoard","nextTurn","move","piece","inCheck","nextTurnMovesList","JSON","stringify","filter","includes","legalCastlingMoves","ARookInitialPosition","HRookInitialPosition","kingInitialPosition","castleMoveLegal","rookInitialPosition","kingHasMoved","hasPieceMoved","rookHasMoved","squaresKingGoesThrough","squaresBetweenOccupied","Math","abs","otherTurnMoves","anyKingSquaresInCheck","squareKingGoesThrough","possibleEnPassantMoves","opposingColorPawnInitialRank","newY","initialPosition","hasMoved","moveIsInMovesList","position1","position2","moveInMovesList","moveType","console","log","yIncrement","endGame","alert","Object","create","handleMove","printMoves"],"mappings":"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","sourcesContent":["import PawnFactory from \"./Pieces/Pawn\";\r\nimport RookFactory from \"./Pieces/Rook\";\r\nimport KnightFactory from \"./Pieces/Knight\";\r\nimport BishopFactory from \"./Pieces/Bishop\";\r\nimport QueenFactory from \"./Pieces/Queen\";\r\nimport KingFactory from \"./Pieces/King\";\r\nimport deepCopy from \"./core/deepCopy\";\r\n\r\nconst ChessFactory = () => {\r\n\r\n    const initializeBoard = () => {\r\n        return ([\r\n            [RookFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), RookFactory('black')],\r\n            [KnightFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), KnightFactory('black')],\r\n            [BishopFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), BishopFactory('black')],\r\n            [QueenFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), QueenFactory('black')],\r\n            [KingFactory('white'), PawnFactory('white'), null, null, PawnFactory('white'), null, PawnFactory('black'), KingFactory('black')],\r\n            [BishopFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), BishopFactory('black')],\r\n            [KnightFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), KnightFactory('black')],\r\n            [RookFactory('white'), PawnFactory('white'), null, null, null, null, PawnFactory('black'), RookFactory('black')],\r\n        ]);\r\n    };\r\n\r\n    //Generates list of moves given a board setup and the color of the current turn\r\n    //Checks if player is in check after move\r\n    const generateImmediateMoves = (board, turn) => {\r\n\r\n        let movesList = [];\r\n\r\n        for (let x = 0; x < 8; x = x + 1) {\r\n            for (let y = 0; y < 8; y = y + 1) {\r\n                if (board[x][y] !== null && board[x][y].color === turn) {\r\n                    let position = [x, y];\r\n                    movesList = movesList.concat(board[x][y].getMoves(board, position));\r\n                }\r\n            }\r\n        }\r\n\r\n        return movesList;\r\n    }\r\n\r\n    //Generates list of legal moves, given the current turn and board\r\n    //Legal move takes the form of [initialPosition, finalPosition]\r\n    const generateLegalMovesList = (board, turn, moveHistory) => {\r\n        let legalMovesList = generateImmediateMoves(board, turn);\r\n\r\n        let illegalMovesList = [];\r\n\r\n        \r\n        //Adds castling moves\r\n        checkForCastle(board, turn, moveHistory).forEach(castleMove => {\r\n            if (castleMove.length > 0) legalMovesList.push(castleMove);\r\n        });\r\n\r\n        checkForEnPassant(board, turn, moveHistory).forEach(enPassantMove => {  \r\n            if (enPassantMove.length > 0) legalMovesList.push(enPassantMove)\r\n        })\r\n\r\n        //Loops through all moves and generates a new board for after each move\r\n        //Checks if player is in check \r\n        //If any of the opposing player's possible moves on the new board attack the player's king, move is illegal\r\n        //Adds illigal moves to illegalMovesList, then removes moves in illegalMovesList from movesList\r\n        for (let i = 0; i < legalMovesList.length; i = i + 1) {\r\n            let possibleMove = legalMovesList[i];\r\n            let resultingBoard = deepCopy(board);\r\n            let positionOfKingOnResultingBoard;\r\n            let nextTurn = (turn === 'white') ? 'black' : 'white';\r\n\r\n            //resultingBoard is the board after the current move being looped has been played\r\n            //resultingBoard[move[1][0]][move[1][1]] = resultingBoard[move[0][0]][move[0][1]];\r\n            //resultingBoard[move[0][0]][move[0][1]] = null;\r\n            if (typeof possibleMove[0] === 'string') {\r\n               move(possibleMove[0], possibleMove[1][0], possibleMove[1][1], resultingBoard)\r\n            } else {\r\n                move('normal', possibleMove[0], possibleMove[1], resultingBoard)\r\n            }\r\n\r\n            //Gets location of current player's king on resultingBoard\r\n            for (let x = 0; x < 8; x = x + 1) {\r\n                for (let y = 0; y < 8; y = y + 1) {\r\n                    if (resultingBoard[x][y] !== null && resultingBoard[x][y].color === turn && resultingBoard[x][y].piece === 'King') {\r\n                        positionOfKingOnResultingBoard = [x, y];\r\n                    }\r\n                }\r\n            }\r\n\r\n            let inCheck = false;\r\n\r\n            let nextTurnMovesList = generateImmediateMoves(resultingBoard, nextTurn);\r\n\r\n            nextTurnMovesList.forEach(move => {\r\n                if (JSON.stringify(move[1]) === JSON.stringify(positionOfKingOnResultingBoard)) inCheck = true;\r\n            });\r\n\r\n            if (inCheck) illegalMovesList.push(legalMovesList[i]);\r\n\r\n        };\r\n\r\n\r\n        //Filters movesList to only include moves that are not in illegalMovesList\r\n        legalMovesList = legalMovesList.filter((move) => !illegalMovesList.includes(move));\r\n\r\n        return legalMovesList\r\n    }\r\n\r\n    //Checks if there are any castling moves\r\n    const checkForCastle = (board, turn, moveHistory) => {\r\n\r\n        let legalCastlingMoves = [];\r\n\r\n        let ARookInitialPosition = turn === 'white' ? [0, 0] : [0, 7];\r\n        let HRookInitialPosition = turn === 'white' ? [7, 0] : [7, 7];\r\n        let kingInitialPosition = turn === 'white' ? [4, 0] : [4, 7];\r\n\r\n        //King castling long\r\n        if (castleMoveLegal(kingInitialPosition, ARookInitialPosition, board, turn, moveHistory)) {\r\n            legalCastlingMoves.push(\r\n                //2D move. First is king, second is rook\r\n                ['castle', [kingInitialPosition, [kingInitialPosition[0] - 2, kingInitialPosition[1]]], [ARookInitialPosition, [ARookInitialPosition[0] + 3, ARookInitialPosition[1]]]]\r\n            );\r\n        }\r\n\r\n        //King castling short\r\n        if (castleMoveLegal(kingInitialPosition, HRookInitialPosition, board, turn, moveHistory)) {\r\n            legalCastlingMoves.push(\r\n                //2D move. First is king, second is rook\r\n                ['castle', [kingInitialPosition, [kingInitialPosition[0] + 2, kingInitialPosition[1]]], [HRookInitialPosition, [HRookInitialPosition[0] - 2, ARookInitialPosition[1]]]]\r\n            );\r\n        }\r\n\r\n        return legalCastlingMoves;\r\n    }\r\n\r\n    //Checks if castling move is legal, given rook/king pair to castle\r\n    const castleMoveLegal = (kingInitialPosition, rookInitialPosition, board, turn, moveHistory) => {\r\n\r\n        let kingHasMoved = hasPieceMoved(kingInitialPosition, moveHistory);\r\n        let rookHasMoved = hasPieceMoved(rookInitialPosition, moveHistory);\r\n\r\n        if (!kingHasMoved && !rookHasMoved) {\r\n            let squaresKingGoesThrough = [];\r\n            //Are there pieces between king and rook?\r\n            let squaresBetweenOccupied = false;\r\n\r\n            //Loops through all squares between x value of king's initial position and rook's initial position\r\n            for (let x = kingInitialPosition[0] > rookInitialPosition[0] ? kingInitialPosition[0] - 1 : rookInitialPosition[0] - 1; x !== 4 && x !== 0; x = x - 1) {\r\n                //King moves two squares. If square is within 2 of king initial square, push to squaresKingGoesThrough\r\n                if (Math.abs(kingInitialPosition[0] - x) <= 2) squaresKingGoesThrough.push([x, kingInitialPosition[1]]);\r\n                //If square has a piece, the squares between are occupied\r\n                if (board[x][kingInitialPosition[1]] !== null) squaresBetweenOccupied = true;\r\n            }\r\n\r\n            //if no positions between them have a piece, check if any squares the king passes are in check\r\n            if (!squaresBetweenOccupied) {\r\n                //Generates other player's moves\r\n                let otherTurnMoves = generateImmediateMoves(board, (turn === 'white') ? 'black' : 'white');\r\n                let anyKingSquaresInCheck = false;\r\n                otherTurnMoves.forEach(move => {\r\n                    squaresKingGoesThrough.forEach(squareKingGoesThrough => {\r\n                        if (JSON.stringify(move[1]) === JSON.stringify(squareKingGoesThrough)) anyKingSquaresInCheck = true;\r\n                    });\r\n                });\r\n\r\n                //Only returns true if 1) no pieces are between and 2) no squares the king goes through are in check\r\n                //Already checked for no pieces between, so returns value of statement \"no squares the king goes through are in check\"\r\n                return anyKingSquaresInCheck === false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n\r\n        //Need logic to handle castling moves in legalMovesList\r\n        //Probably just if any move is a 2d array, both moves are made\r\n        //Since castling should really only be the only move with two moves\r\n        //Unless pawn promotion also has two moves? \r\n    }\r\n\r\n    //Checks if there are any en passant moves\r\n    const checkForEnPassant = (board, turn, moveHistory) => {\r\n\r\n        let possibleEnPassantMoves = [];\r\n        //Y value pawns can en passant from, depending on piece color\r\n        let y = turn === 'white' ? 4 : 3;\r\n\r\n        //for each pawn\r\n        for (let x = 0; x < 8; x = x + 1) {\r\n            if (board[x][y] !== null && board[x][y].piece === 'Pawn' && board[x][y].color === turn) {\r\n                let opposingColorPawnInitialRank = turn === 'white' ? 6 : 1;\r\n                //if the square is occupied by a pawn of the opposing color\r\n                if (x + 1 < 8 && board[x + 1][y] !== null && board[x + 1][y].piece === 'Pawn' && board[x + 1][y].color !== turn) {\r\n                    //First checks if the last move started on back rank, second checks if the last move ended next to the piece\r\n                    if (moveHistory[moveHistory.length - 1][0][1] === opposingColorPawnInitialRank && (moveHistory[moveHistory.length - 1][1][0] === x + 1 && moveHistory[moveHistory.length - 1][1][1] === y)) {\r\n                        //don't have to worry about a piece being in the spot, because the most recent pawn move passed over it\r\n                        let newY = turn === 'white' ? 5 : 2;\r\n                        possibleEnPassantMoves.push('en passant', [[x, y], [x + 1, newY]]);\r\n                    }\r\n                } else if (x - 1 > 0 && board[x - 1][y] !== null && board[x - 1][y].piece === 'Pawn' && board[x - 1][y].color !== turn) {\r\n                    if (moveHistory[moveHistory.length - 1][0][1] === opposingColorPawnInitialRank && (moveHistory[moveHistory.length - 1][1][0] === x - 1 && moveHistory[moveHistory.length - 1][1][1] === y)) {\r\n                        //don't have to worry about a piece being in the spot, because the most recent pawn move passed over it\r\n                        let newY = turn === 'white' ? 5 : 2;\r\n                        possibleEnPassantMoves.push('en passant', [[x, y], [x - 1, newY]]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        \r\n        return possibleEnPassantMoves;\r\n    }\r\n\r\n    //Checks if piece has moved, given initial position and history of moves\r\n    const hasPieceMoved = (initialPosition, moveHistory) => {\r\n        let hasMoved = false;\r\n\r\n        moveHistory.forEach(move => {\r\n            if (JSON.stringify(move[0]) === JSON.stringify(initialPosition)) hasMoved = true;\r\n        });\r\n\r\n        return hasMoved;\r\n    }\r\n\r\n    //Checks if move is in list of legal moves\r\n    //Returns string. String can be 'invalid', 'normal', 'castle', 'en passant'\r\n    const moveIsInMovesList = (position1, position2, movesList) => {\r\n\r\n        let moveInMovesList = 'invalid';\r\n\r\n        movesList.forEach(move => {\r\n            if (JSON.stringify(move) === JSON.stringify([position1, position2])) moveInMovesList = 'normal';\r\n            //Checks for castling or en passant, which are 2D arrays\r\n            //Type of move is stored at move[0]\r\n            if (typeof move[0] === 'string' && JSON.stringify(move[1]) === JSON.stringify([position1, position2])) moveInMovesList = move[0];\r\n        });\r\n\r\n        return moveInMovesList;\r\n    }\r\n\r\n    //Makes move on board, adds move to history\r\n    const move = (moveType, position1, position2, board) => {\r\n        console.log(moveType)\r\n        switch (moveType) {\r\n            case 'normal':\r\n                //Sets position2 equal to value of position1\r\n                board[position2[0]][position2[1]] = board[position1[0]][position1[1]];\r\n                //Clears position1\r\n                board[position1[0]][position1[1]] = null;\r\n                break;\r\n            case 'castle':\r\n                //Moves king\r\n                board[position2[0]][position2[1]] = board[position1[0]][position1[1]];\r\n                //Set original king position to null\r\n                board[position1[0]][position1[1]] = null;\r\n                //Move rooks based on side castling to (found based on position2[0], which gives column king moves to)\r\n                //Position2[1] will always give the row\r\n                //Castle long\r\n                if (position2[0] === 2) {\r\n                    //Moves rook\r\n                    board[3][position2[1]] = board[0][position2[1]];\r\n                    //Sets rook initial position to null\r\n                    board[0][position2[1]] = null;\r\n                }\r\n                //Castle short\r\n                else {\r\n                    //Moves rook\r\n                    board[5][position2[1]] = board[7][position2[1]];\r\n                    //Sets rook initial position to null\r\n                    board[7][position2[1]] = null;\r\n                }\r\n                break;\r\n            case 'en passant':\r\n                console.log(position2[1])\r\n                let yIncrement = position1[1] === 4 ? -1 : 1;\r\n                console.log(yIncrement)\r\n                board[position2[0]][position2[1]] = board[position1[0]][position1[1]];\r\n                board[position1[0]][position1[1]] = null;\r\n                console.log(`${position2[0]}, ${position2[1] + yIncrement}`)\r\n                board[position2[0]][position2[1] + yIncrement] = null;\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n    }\r\n\r\n    const endGame = (turn) => {\r\n        alert('End Game')\r\n    }\r\n\r\n    return Object.create({\r\n        board: initializeBoard(),\r\n        turn: 'white',\r\n        legalMovesList: generateImmediateMoves(initializeBoard(), 'white'),\r\n        moveHistory: [],\r\n\r\n        //I'll need to add functions for castling/converting pawn on end rank (should both of those go here?)\r\n        handleMove(position1, position2) {\r\n\r\n            let moveType = moveIsInMovesList(position1, position2, this.legalMovesList);\r\n            //If move is in list of legal moves\r\n            if (moveType !== 'invalid') {\r\n                //Makes move on board\r\n                move(moveType, position1, position2, this.board, this.moveHistory);\r\n\r\n                //Adds move to move history\r\n                this.moveHistory.push([position1, position2]);\r\n\r\n                //Changes turn\r\n                this.turn === 'white' ? this.turn = 'black' : this.turn = 'white';\r\n\r\n                //Re-generates movesList for new board and turn\r\n                this.legalMovesList = generateLegalMovesList(this.board, this.turn, this.moveHistory);\r\n\r\n                //if there are no legal moves, the turn at the beginning of the function wins\r\n                if (this.legalMovesList.length === 0) endGame();\r\n            }\r\n        },\r\n        printMoves() {\r\n            this.generateLegalMovesList(this.board, this.turn);\r\n            console.log(this.legalMovesList);\r\n        }\r\n    })\r\n\r\n}\r\n\r\nexport default ChessFactory;"]},"metadata":{},"sourceType":"module"}